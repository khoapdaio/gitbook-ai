# 994.  Rotting Oranges

## **‚ùì Problem:**

üîó [LeetCode 994 - Rotting Oranges](https://leetcode.com/problems/rotting-oranges)

***

## **üìù M√¥ t·∫£:**

Cho m·ªôt l∆∞·ªõi `grid` k√≠ch th∆∞·ªõc `m x n` ch·ª©a c√°c gi√° tr·ªã:

* `0`: √î tr·ªëng.
* `1`: Qu·∫£ cam t∆∞∆°i.
* `2`: Qu·∫£ cam h·ªèng.

M·ªói ph√∫t, **m·ªçi qu·∫£ cam h·ªèng c√≥ th·ªÉ l√¢y lan sang qu·∫£ cam t∆∞∆°i c·∫°nh n√≥ theo 4 h∆∞·ªõng (tr√™n, d∆∞·ªõi, tr√°i, ph·∫£i).**

üëâ **Nhi·ªám v·ª•:** T√≠nh s·ªë ph√∫t √≠t nh·∫•t ƒë·ªÉ t·∫•t c·∫£ qu·∫£ cam t∆∞∆°i b·ªã h·ªèng. N·∫øu kh√¥ng th·ªÉ l√†m h·ªèng t·∫•t c·∫£ qu·∫£ cam, tr·∫£ v·ªÅ `-1`.

***

## **üí° V√≠ d·ª•:**

#### ‚úÖ **V√≠ d·ª• 1:**

**Input:**

```
grid = [[2,1,1],
        [1,1,0],
        [0,1,1]]
```

**Output:** `4`\
**Gi·∫£i th√≠ch:**

* Ph√∫t `1`: `(0,1)`, `(1,0)`, `(1,1)` h·ªèng.
* Ph√∫t `2`: `(1,2)`, `(2,1)` h·ªèng.
* Ph√∫t `3`: `(2,2)` h·ªèng.
* Ph√∫t `4`: T·∫•t c·∫£ ƒë√£ h·ªèng.

***

#### ‚úÖ **V√≠ d·ª• 2:**

**Input:**

```
grid = [[2,1,1],
        [0,1,1],
        [1,0,1]]
```

**Output:** `-1`\
**Gi·∫£i th√≠ch:** Cam `(2,2)` kh√¥ng th·ªÉ b·ªã h·ªèng do b·ªã c√¥ l·∫≠p.

***

#### ‚úÖ **V√≠ d·ª• 3:**

**Input:**

```
grid = [[0,2]]
```

**Output:** `0`\
**Gi·∫£i th√≠ch:** Kh√¥ng c√≥ qu·∫£ cam t∆∞∆°i, kh√¥ng c·∫ßn ch·ªù ƒë·ª£i.

***

## **üöÄ Gi·∫£i ph√°p**

#### **üîπ √ù t∆∞·ªüng:**

* B√†i to√°n n√†y y√™u c·∫ßu **t√¨m s·ªë ph√∫t √≠t nh·∫•t ƒë·ªÉ to√†n b·ªô cam b·ªã h·ªèng** ‚Üí s·ª≠ d·ª•ng **BFS (Breadth-First Search)**.
* Duy·ªát qua to√†n b·ªô `grid`, ƒë∆∞a **t·∫•t c·∫£ qu·∫£ cam h·ªèng v√†o h√†ng ƒë·ª£i `queue`** l√†m **ƒëi·ªÉm b·∫Øt ƒë·∫ßu**.
* M·ªói l·∫ßn BFS **(1 ph√∫t)**, **m·ªçi qu·∫£ cam h·ªèng l√¢y lan sang cam t∆∞∆°i** c·∫°nh n√≥.
* D·ª´ng l·∫°i khi kh√¥ng c√≤n cam n√†o ƒë·ªÉ l√¢y nhi·ªÖm.

***

## **üìú Code**

{% tabs %}
{% tab title="C++" %}
```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        queue<pair<int, int>> q;
        int freshCount = 0, minutes = 0;
        
        // ƒê∆∞a cam h·ªèng v√†o h√†ng ƒë·ª£i v√† ƒë·∫øm cam t∆∞∆°i
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 2) q.push({i, j});
                else if (grid[i][j] == 1) freshCount++;
            }
        }
        
        vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        
        while (!q.empty() && freshCount > 0) {
            int size = q.size();
            minutes++;
            for (int i = 0; i < size; i++) {
                auto [x, y] = q.front(); q.pop();
                for (auto [dx, dy] : directions) {
                    int nx = x + dx, ny = y + dy;
                    if (nx >= 0 && ny >= 0 && nx < m && ny < n && grid[nx][ny] == 1) {
                        grid[nx][ny] = 2;
                        q.push({nx, ny});
                        freshCount--;
                    }
                }
            }
        }
        
        return freshCount == 0 ? minutes : -1;
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
class Solution {
    public int orangesRotting(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        Queue<int[]> q = new LinkedList<>();
        int freshCount = 0, minutes = 0;

        // ƒê∆∞a cam h·ªèng v√†o h√†ng ƒë·ª£i v√† ƒë·∫øm cam t∆∞∆°i
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 2) q.offer(new int[]{i, j});
                else if (grid[i][j] == 1) freshCount++;
            }
        }

        int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

        while (!q.isEmpty() && freshCount > 0) {
            minutes++;
            int size = q.size();
            for (int i = 0; i < size; i++) {
                int[] cell = q.poll();
                int x = cell[0], y = cell[1];
                for (int[] dir : directions) {
                    int nx = x + dir[0], ny = y + dir[1];
                    if (nx >= 0 && ny >= 0 && nx < m && ny < n && grid[nx][ny] == 1) {
                        grid[nx][ny] = 2;
                        q.offer(new int[]{nx, ny});
                        freshCount--;
                    }
                }
            }
        }

        return freshCount == 0 ? minutes : -1;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
from collections import deque

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        q = deque()
        fresh_count = 0
        minutes = 0

        # ƒê∆∞a cam h·ªèng v√†o h√†ng ƒë·ª£i v√† ƒë·∫øm cam t∆∞∆°i
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 2:
                    q.append((i, j))
                elif grid[i][j] == 1:
                    fresh_count += 1

        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        
        while q and fresh_count > 0:
            minutes += 1
            for _ in range(len(q)):
                x, y = q.popleft()
                for dx, dy in directions:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:
                        grid[nx][ny] = 2
                        q.append((nx, ny))
                        fresh_count -= 1

        return minutes if fresh_count == 0 else -1
```
{% endtab %}
{% endtabs %}

***

## **üéØ ƒêi·ªÉm ch√≠nh**

‚úî **S·ª≠ d·ª•ng BFS ƒë·ªÉ lan truy·ªÅn b·ªánh nhanh nh·∫•t.**\
‚úî **L∆∞u c√°c cam h·ªèng ban ƒë·∫ßu v√†o h√†ng ƒë·ª£i v√† m·ªü r·ªông t·ª´ng b∆∞·ªõc.**\
‚úî **D·ª´ng khi kh√¥ng c√≤n cam t∆∞∆°i n√†o ƒë·ªÉ nhi·ªÖm.**\
‚úî **N·∫øu v·∫´n c√≤n cam t∆∞∆°i sau khi BFS k·∫øt th√∫c, tr·∫£ v·ªÅ `-1`.**

***

## **‚è≥ ƒê·ªô ph·ª©c t·∫°p thu·∫≠t to√°n**

| Ph∆∞∆°ng ph√°p | Th·ªùi gian  | Kh√¥ng gian |
| ----------- | ---------- | ---------- |
| **BFS**     | `O(m * n)` | `O(m * n)` |

* `O(m * n)`: duy·ªát qua to√†n b·ªô `grid` ƒë·ªÉ ki·ªÉm tra cam t∆∞∆°i.
* Kh√¥ng gian `O(m * n)`: d√πng `queue` ƒë·ªÉ l∆∞u tr·∫°ng th√°i BFS.

***

## **üìå T·ªïng k·∫øt**

* ‚úÖ **S·ª≠ d·ª•ng BFS ƒë·ªÉ t√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t trong m·∫°ng l∆∞·ªõi (t∆∞∆°ng t·ª± b√†i to√°n l√¢y lan d·ªãch b·ªánh).**
* ‚úÖ **C·∫ßn theo d√µi s·ªë cam t∆∞∆°i c√≤n l·∫°i ƒë·ªÉ x√°c ƒë·ªãnh ƒëi·ªÅu ki·ªán d·ª´ng.**
* ‚úÖ **Th·ªùi gian ch·∫°y `O(m * n)`, t·ªëi ∆∞u cho b√†i to√°n.**
