# 238. Product of Array Except Self

## Problem

[https://leetcode.com/problems/product-of-array-except-self](https://leetcode.com/problems/product-of-array-except-self)

## M√¥ t·∫£

Cho m·ªôt m·∫£ng s·ªë nguy√™n `nums`, tr·∫£ v·ªÅ m·ªôt m·∫£ng `output` sao cho `output[i]` b·∫±ng **t√≠ch c·ªßa t·∫•t c·∫£ c√°c ph·∫ßn t·ª≠ trong `nums` ngo·∫°i tr·ª´ `nums[i]`**.

üö® **L∆∞u √Ω:**

* **Kh√¥ng s·ª≠ d·ª•ng ph√©p chia (`/`)**.
* **Gi·∫£i ph√°p ph·∫£i c√≥ ƒë·ªô ph·ª©c t·∫°p `O(n)`**.

## **V√≠ d·ª•**

**‚úÖ V√≠ d·ª• 1**

```
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
```

**Gi·∫£i th√≠ch:**

* `output[0] = 2 * 3 * 4 = 24`
* `output[1] = 1 * 3 * 4 = 12`
* `output[2] = 1 * 2 * 4 = 8`
* `output[3] = 1 * 2 * 3 = 6`

**‚úÖ V√≠ d·ª• 2**

```
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
```

#### **Gi·∫£i ph√°p: D√πng m·∫£ng t√≠ch ti·ªÅn t·ªë v√† h·∫≠u t·ªë (Prefix & Suffix Product)**

1. **T·∫°o m·∫£ng `prefix` (t√≠ch b√™n tr√°i):**
   * `prefix[i] = prefix[i-1] * nums[i-1]`
   * `prefix[0] = 1` (kh√¥ng c√≥ ph·∫ßn t·ª≠ n√†o b√™n tr√°i).
2. **T·∫°o m·∫£ng `suffix` (t√≠ch b√™n ph·∫£i):**
   * `suffix[i] = suffix[i+1] * nums[i+1]`
   * `suffix[len-1] = 1` (kh√¥ng c√≥ ph·∫ßn t·ª≠ n√†o b√™n ph·∫£i).
3. **T√≠nh `output[i] = prefix[i] * suffix[i]`**.

## **ƒêi·ªÉm ch√≠nh**

* **Kh√¥ng d√πng ph√©p chia**.
* **Kh√¥ng c·∫ßn m·∫£ng `suffix`, ch·ªâ d√πng bi·∫øn `rightProduct` ƒë·ªÉ ti·∫øt ki·ªám kh√¥ng gian**.
* **ƒê·ªô ph·ª©c t·∫°p `O(n)`, kh√¥ng d√πng v√≤ng l·∫∑p l·ªìng nhau**.

## Code

{% tabs %}
{% tab title="C++" %}
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> output(n, 1);

        // B∆∞·ªõc 1: T√≠ch prefix
        for (int i = 1; i < n; i++) {
            output[i] = output[i - 1] * nums[i - 1];
        }

        // B∆∞·ªõc 2: T√≠ch suffix v√† nh√¢n v·ªõi output
        int rightProduct = 1;
        for (int i = n - 1; i >= 0; i--) {
            output[i] *= rightProduct;
            rightProduct *= nums[i];
        }

        return output;
    }
};

```


{% endtab %}

{% tab title="Java" %}
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] output = new int[n];

        // B∆∞·ªõc 1: T√≠nh prefix product
        output[0] = 1;
        for (int i = 1; i < n; i++) {
            output[i] = output[i - 1] * nums[i - 1];
        }

        // B∆∞·ªõc 2: T√≠nh suffix product v√† nh√¢n v√†o output
        int rightProduct = 1;
        for (int i = n - 1; i >= 0; i--) {
            output[i] *= rightProduct;
            rightProduct *= nums[i];
        }

        return output;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
from typing import List

class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        output = [1] * n

        # B∆∞·ªõc 1: T√≠nh prefix product
        for i in range(1, n):
            output[i] = output[i - 1] * nums[i - 1]

        # B∆∞·ªõc 2: T√≠nh suffix product v√† nh√¢n v√†o output
        rightProduct = 1
        for i in range(n - 1, -1, -1):
            output[i] *= rightProduct
            rightProduct *= nums[i]

        return output
```
{% endtab %}
{% endtabs %}
