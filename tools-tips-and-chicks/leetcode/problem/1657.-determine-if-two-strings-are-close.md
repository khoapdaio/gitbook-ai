# 1657. Determine if Two Strings Are Close

## Problem

[https://leetcode.com/problems/determine-if-two-strings-are-close](https://leetcode.com/problems/determine-if-two-strings-are-close)

## **üìå M√¥ t·∫£ b√†i to√°n**

Cho hai chu·ªói `word1` v√† `word2`, h√£y ki·ªÉm tra xem ch√∫ng c√≥ th·ªÉ tr·ªü th√†nh **t∆∞∆°ng ƒë∆∞∆°ng** (close) hay kh√¥ng b·∫±ng c√°ch th·ª±c hi·ªán **c√°c ph√©p bi·∫øn ƒë·ªïi sau**:

1. **Swap b·∫•t k·ª≥ hai k√Ω t·ª± n√†o trong chu·ªói** (ho√°n ƒë·ªïi v·ªã tr√≠).
2. **Thay th·∫ø t·∫•t c·∫£ c√°c l·∫ßn xu·∫•t hi·ªán c·ªßa m·ªôt k√Ω t·ª± b·∫±ng m·ªôt k√Ω t·ª± kh√°c (mi·ªÖn l√† t·∫ßn su·∫•t gi·ªØ nguy√™n)**.

üîπ **Tr·∫£ v·ªÅ `true` n·∫øu c√≥ th·ªÉ l√†m cho `word1` v√† `word2` gi·ªëng nhau, ng∆∞·ª£c l·∫°i tr·∫£ v·ªÅ `false`.**

***

## **üí° V√≠ d·ª•**

**‚úÖ V√≠ d·ª• 1**

```
Input: word1 = "abc", word2 = "bca"
Output: true
```

**Gi·∫£i th√≠ch:**

* C√≥ th·ªÉ ho√°n ƒë·ªïi v·ªã tr√≠ k√Ω t·ª± ƒë·ªÉ chuy·ªÉn `"abc"` th√†nh `"bca"`.
* V√¨ c√°c k√Ω t·ª± gi·ªëng nhau v√† t·∫ßn su·∫•t gi·ªëng nhau ‚Üí **Tr·∫£ v·ªÅ `true`**.

***

**‚úÖ V√≠ d·ª• 2**

```
Input: word1 = "a", word2 = "aa"
Output: false
```

**Gi·∫£i th√≠ch:**

* `word1` c√≥ `"a"` xu·∫•t hi·ªán **1 l·∫ßn**, `word2` c√≥ `"a"` xu·∫•t hi·ªán **2 l·∫ßn**.
* Kh√¥ng th·ªÉ l√†m ch√∫ng gi·ªëng nhau ‚Üí **Tr·∫£ v·ªÅ `false`**.

***

**‚úÖ V√≠ d·ª• 3**

```
Input: word1 = "cabbba", word2 = "abbccc"
Output: true
```

**Gi·∫£i th√≠ch:**

* `word1`: `c(1), a(1), b(3)`.
* `word2`: `a(1), b(3), c(1)`.
* C√≥ c√πng t·∫≠p k√Ω t·ª± `{a, b, c}` v√† **t·∫ßn su·∫•t s·ªë l·∫ßn xu·∫•t hi·ªán gi·ªëng nhau** (`[1, 1, 3]`).
* ‚Üí **Tr·∫£ v·ªÅ `true`**.

***

## **üöÄ Gi·∫£i ph√°p: S·ª≠ d·ª•ng T·∫ßn su·∫•t & T·∫≠p k√Ω t·ª±**

üìå **ƒêi·ªÅu ki·ªán ƒë·ªÉ hai chu·ªói c√≥ th·ªÉ tr·ªü th√†nh t∆∞∆°ng ƒë∆∞∆°ng:**

1. **Ch√∫ng ph·∫£i c√≥ c√πng t·∫≠p k√Ω t·ª±.**
   * V√≠ d·ª•: `"abc"` v√† `"bca"` c√≥ c√πng t·∫≠p `{a, b, c}` ‚Üí c√≥ th·ªÉ ho√°n ƒë·ªïi k√Ω t·ª±.
   * `"abc"` v√† `"xyz"` c√≥ t·∫≠p kh√°c nhau `{a, b, c}` ‚â† `{x, y, z}` ‚Üí `false`.
2. **T·∫ßn su·∫•t xu·∫•t hi·ªán c·ªßa c√°c k√Ω t·ª± ph·∫£i c√≥ th·ªÉ ho√°n ƒë·ªïi ƒë∆∞·ª£c.**
   * V√≠ d·ª•: `"abbccc"` v√† `"cabbba"` c√≥ **t·∫ßn su·∫•t gi·ªëng nhau** (`[1, 2, 3]`).

***

#### **üîπ B∆∞·ªõc th·ª±c hi·ªán**

1. **ƒê·∫øm s·ªë l·∫ßn xu·∫•t hi·ªán c·ªßa t·ª´ng k√Ω t·ª± trong `word1` v√† `word2`.**
2. **So s√°nh t·∫≠p k√Ω t·ª± trong hai chu·ªói:** N·∫øu kh√°c nhau ‚Üí `false`.
3. **So s√°nh danh s√°ch t·∫ßn su·∫•t sau khi s·∫Øp x·∫øp:** N·∫øu gi·ªëng nhau ‚Üí `true`.

***

## **üìú Code**

{% tabs %}
{% tab title="C++" %}
```cpp
class Solution {
public:
    bool closeStrings(string word1, string word2) {
        if (word1.size() != word2.size()) return false;

        vector<int> freq1(26, 0), freq2(26, 0);
        unordered_set<char> set1, set2;

        for (char c : word1) {
            freq1[c - 'a']++;
            set1.insert(c);
        }
        for (char c : word2) {
            freq2[c - 'a']++;
            set2.insert(c);
        }

        if (set1 != set2) return false;

        sort(freq1.begin(), freq1.end());
        sort(freq2.begin(), freq2.end());

        return freq1 == freq2;
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
class Solution {
    public boolean closeStrings(String word1, String word2) {
        if (word1.length() != word2.length()) return false;

        int[] freq1 = new int[26], freq2 = new int[26];
        Set<Character> set1 = new HashSet<>(), set2 = new HashSet<>();

        for (char c : word1.toCharArray()) {
            freq1[c - 'a']++;
            set1.add(c);
        }
        for (char c : word2.toCharArray()) {
            freq2[c - 'a']++;
            set2.add(c);
        }

        if (!set1.equals(set2)) return false;

        Arrays.sort(freq1);
        Arrays.sort(freq2);

        return Arrays.equals(freq1, freq2);
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
class Solution:
    def closeStrings(self, word1: str, word2: str) -> bool:
        if len(word1) != len(word2):
            return False

        freq1 = Counter(word1)
        freq2 = Counter(word2)

        return set(freq1.keys()) == set(freq2.keys()) and sorted(freq1.values()) == sorted(freq2.values())
```
{% endtab %}
{% endtabs %}

***

## **‚è≥ ƒê·ªô ph·ª©c t·∫°p thu·∫≠t to√°n**

| Ph∆∞∆°ng ph√°p             | Th·ªùi gian    | Kh√¥ng gian |
| ----------------------- | ------------ | ---------- |
| **D√πng HashMap + Sort** | `O(n log n)` | `O(1)`     |

‚úÖ **Duy·ªát qua `word1` v√† `word2` (`O(n)`) ƒë·ªÉ ƒë·∫øm s·ªë l·∫ßn xu·∫•t hi·ªán.**\
‚úÖ **So s√°nh t·∫≠p k√Ω t·ª± trong `O(1)`.**\
‚úÖ **S·∫Øp x·∫øp t·∫ßn su·∫•t (`O(26 log 26) = O(1)`, do c√≥ t·ªëi ƒëa 26 k√Ω t·ª±).**

***

## **üìå T·ªïng k·∫øt**

‚úî **D√πng HashMap (`Counter`) ƒë·ªÉ ƒë·∫øm s·ªë l·∫ßn xu·∫•t hi·ªán c·ªßa k√Ω t·ª±**.\
‚úî **D√πng Set ƒë·ªÉ ki·ªÉm tra t·∫≠p k√Ω t·ª± c√≥ gi·ªëng nhau kh√¥ng**.\
‚úî **S·∫Øp x·∫øp danh s√°ch t·∫ßn su·∫•t v√† so s√°nh ƒë·ªÉ ƒë·∫£m b·∫£o c√≥ th·ªÉ ƒë·ªïi v·ªã tr√≠**.\
‚úî **Th·ªùi gian `O(n log n)`, t·ªëi ∆∞u cho b√†i to√°n n√†y**.



