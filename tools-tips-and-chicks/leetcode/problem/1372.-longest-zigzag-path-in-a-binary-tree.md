# 1372. Longest ZigZag Path in a Binary Tree

## Problem

[https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree](https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/)

## **ğŸ“Œ MÃ´ táº£ bÃ i toÃ¡n**

Cho má»™t **cÃ¢y nhá»‹ phÃ¢n**, hÃ£y tÃ¬m Ä‘á»™ dÃ i dÃ i nháº¥t cá»§a **Ä‘Æ°á»ng Ä‘i zigzag** trong cÃ¢y.

ğŸ“Œ **Quy táº¯c ZigZag:**

* Má»™t Ä‘Æ°á»ng Ä‘i **ZigZag** báº¯t Ä‘áº§u tá»« má»™t node báº¥t ká»³, má»—i bÆ°á»›c pháº£i chuyá»ƒn tá»« **trÃ¡i sang pháº£i** hoáº·c **pháº£i sang trÃ¡i** liÃªn tá»¥c.
* Äá»™ dÃ i Ä‘Æ°á»ng Ä‘i = sá»‘ bÆ°á»›c di chuyá»ƒn trong chuá»—i Ä‘Ã³.

ğŸ“Œ **RÃ ng buá»™c:**

* `1 <= Number of nodes <= 5 * 10^4`
* `0 <= Node.val <= 100`

***

## **ğŸ’¡ VÃ­ dá»¥**

#### âœ… **VÃ­ dá»¥ 1**

```
Input: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]
Output: 3
```

**CÃ¢y nhá»‹ phÃ¢n:**

```
       1
        \
         1
        / \
       1   1
      /     \
     1       1
              \
               1
```

ğŸ“Œ **Zigzag dÃ i nháº¥t:** `1 â†’ right â†’ 1 â†’ left â†’ 1 â†’ right â†’ 1`\
âœ… **Káº¿t quáº£:** `3`

***

#### âœ… **VÃ­ dá»¥ 2**

```
Input: root = [1,1,1,null,1,null,null,1,1,null,1]
Output: 4
```

```
       1
      / \
     1   1
      \
       1
      / \
     1   1
          \
           1
```

ğŸ“Œ **Zigzag dÃ i nháº¥t:** `1 â†’ right â†’ 1 â†’ left â†’ 1 â†’ right â†’ 1 â†’ left â†’ 1`\
âœ… **Káº¿t quáº£:** `4`

***

## **ğŸš€ Giáº£i phÃ¡p 1: DFS - Duyá»‡t tá»«ng node**

#### ğŸ“Œ **Ã tÆ°á»Ÿng chÃ­nh:**

1. Vá»›i má»—i node, kiá»ƒm tra hai trÆ°á»ng há»£p:
   * **Báº¯t Ä‘áº§u tá»« trÃ¡i:** Ä‘i `right â†’ left â†’ right`...
   * **Báº¯t Ä‘áº§u tá»« pháº£i:** Ä‘i `left â†’ right â†’ left`...
2. DÃ¹ng **Ä‘á»‡ quy DFS** Ä‘á»ƒ duyá»‡t tá»«ng node vÃ  cáº­p nháº­t Ä‘á»™ dÃ i lá»›n nháº¥t.

***

#### âœ… **Java - DFS (Top-down)**

```java
class Solution {
    private int maxZigZag = 0;

    public int longestZigZag(TreeNode root) {
        if (root == null) return 0;
        dfs(root.left, 1, true);
        dfs(root.right, 1, false);
        return maxZigZag;
    }

    private void dfs(TreeNode node, int length, boolean isLeft) {
        if (node == null) return;
        maxZigZag = Math.max(maxZigZag, length);

        if (isLeft) {
            dfs(node.right, length + 1, false);
            dfs(node.left, 1, true);  // Reset náº¿u Ä‘i cÃ¹ng chiá»u
        } else {
            dfs(node.left, length + 1, true);
            dfs(node.right, 1, false);
        }
    }
}
```

âœ… **Ã tÆ°á»Ÿng:**

* `dfs(node, length, isLeft)` â†’ Kiá»ƒm tra tiáº¿p náº¿u Ä‘i `left` hoáº·c `right`.
* Náº¿u Ä‘i theo cÃ¹ng hÆ°á»›ng **liÃªn tá»¥c**, reset `length = 1`.
* **Duyá»‡t toÃ n bá»™ cÃ¢y**, cáº­p nháº­t `maxZigZag`.

â³ **Äá»™ phá»©c táº¡p:**

* **Thá»i gian:** `O(n)` â†’ Má»—i node Ä‘Æ°á»£c duyá»‡t Ä‘Ãºng **1 láº§n**.
* **KhÃ´ng gian:** `O(h)` â†’ `h` lÃ  Ä‘á»™ cao cá»§a cÃ¢y (stack cá»§a DFS).

***

## **ğŸš€ Giáº£i phÃ¡p 2: DFS - Bottom-up (Tráº£ vá» 2 giÃ¡ trá»‹)**

#### ğŸ“Œ **Ã tÆ°á»Ÿng chÃ­nh:**

* Thay vÃ¬ duyá»‡t tá»« gá»‘c, ta **duyá»‡t tá»« lÃ¡** vÃ  **tráº£ vá» 2 giÃ¡ trá»‹**:
  * **left\_path**: Äá»™ dÃ i zigzag náº¿u Ä‘i sang trÃ¡i trÆ°á»›c.
  * **right\_path**: Äá»™ dÃ i zigzag náº¿u Ä‘i sang pháº£i trÆ°á»›c.
* Táº¡i má»—i node, cáº­p nháº­t `maxZigZag = max(left_path, right_path)`.

***

#### âœ… **Java - DFS (Bottom-up)**

```java
class Solution {
    private int maxZigZag = 0;

    public int longestZigZag(TreeNode root) {
        dfs(root);
        return maxZigZag;
    }

    private int[] dfs(TreeNode node) {
        if (node == null) return new int[]{-1, -1}; // Base case
        
        int[] left = dfs(node.left);
        int[] right = dfs(node.right);
        
        int leftPath = left[1] + 1;  // Náº¿u Ä‘i trÃ¡i â†’ pháº£i
        int rightPath = right[0] + 1; // Náº¿u Ä‘i pháº£i â†’ trÃ¡i
        
        maxZigZag = Math.max(maxZigZag, Math.max(leftPath, rightPath));
        
        return new int[]{leftPath, rightPath};
    }
}
```

âœ… **Ã tÆ°á»Ÿng:**

* `dfs(node)` **tráº£ vá» máº£ng** `[leftPath, rightPath]`.
* Má»—i node cáº­p nháº­t `maxZigZag` vá»›i giÃ¡ trá»‹ lá»›n nháº¥t.

â³ **Äá»™ phá»©c táº¡p:**

* **Thá»i gian:** `O(n)`, vÃ¬ má»—i node duyá»‡t Ä‘Ãºng 1 láº§n.
* **KhÃ´ng gian:** `O(h)`, vá»›i `h` lÃ  Ä‘á»™ sÃ¢u cá»§a cÃ¢y.

***

## **ğŸš€ Giáº£i phÃ¡p 3: BFS (Duyá»‡t theo táº§ng - Iterative)**

ğŸ“Œ **Ã tÆ°á»Ÿng:**

* DÃ¹ng **Queue** Ä‘á»ƒ duyá»‡t theo táº§ng (BFS).
* LÆ°u `node`, `length`, `direction`.

***

#### âœ… **Java - BFS**

```java
import java.util.*;

class Solution {
    public int longestZigZag(TreeNode root) {
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{root.left != null ? root.left.val : 0, 1, 0}); // Äi trÃ¡i
        queue.offer(new int[]{root.right != null ? root.right.val : 0, 1, 1}); // Äi pháº£i
        int maxZigZag = 0;

        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            maxZigZag = Math.max(maxZigZag, curr[1]);

            TreeNode node = (curr[2] == 0) ? root.left : root.right;
            if (node == null) continue;

            queue.offer(new int[]{node.left != null ? node.left.val : 0, curr[1] + 1, 1});
            queue.offer(new int[]{node.right != null ? node.right.val : 0, curr[1] + 1, 0});
        }

        return maxZigZag;
    }
}
```

âœ… **Ã tÆ°á»Ÿng:**

* Queue lÆ°u `{node, length, direction}`
* **Duyá»‡t theo táº§ng** báº±ng BFS, cáº­p nháº­t `maxZigZag`.

â³ **Äá»™ phá»©c táº¡p:**

* **Thá»i gian:** `O(n)`, má»—i node duyá»‡t Ä‘Ãºng 1 láº§n.
* **KhÃ´ng gian:** `O(n)`, vá»›i `n` lÃ  sá»‘ node.

***

## **â³ Äá»™ phá»©c táº¡p thuáº­t toÃ¡n**

| PhÆ°Æ¡ng phÃ¡p         | Thá»i gian | KhÃ´ng gian |
| ------------------- | --------- | ---------- |
| **DFS (Top-down)**  | `O(n)`    | `O(h)`     |
| **DFS (Bottom-up)** | `O(n)`    | `O(h)`     |
| **BFS (Queue)**     | `O(n)`    | `O(n)`     |

***

## **ğŸ“Œ Tá»•ng káº¿t**

âœ” **DFS Bottom-up** lÃ  cÃ¡ch tá»‘i Æ°u nháº¥t.\
âœ” **BFS phÃ¹ há»£p khi cáº§n duyá»‡t theo táº§ng.**\
âœ” **á»¨ng dá»¥ng:** TÃ¬m Ä‘Æ°á»ng Ä‘i ZigZag trong cÃ¢y.
