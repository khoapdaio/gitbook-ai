# 1448. Count Good Nodes in Binary Tree

## Problem

[https://leetcode.com/problems/count-good-nodes-in-binary-tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)

## **ğŸ“Œ MÃ´ táº£ bÃ i toÃ¡n**

* Má»™t node Ä‘Æ°á»£c gá»i lÃ  **"good node"** náº¿u trÃªn Ä‘Æ°á»ng Ä‘i tá»« **gá»‘c Ä‘áº¿n node Ä‘Ã³**, nÃ³ lÃ  **giÃ¡ trá»‹ lá»›n nháº¥t** xuáº¥t hiá»‡n.
* Cho cÃ¢y nhá»‹ phÃ¢n `root`, Ä‘áº¿m sá»‘ **"good nodes"** trong cÃ¢y.

ğŸ“Œ **RÃ ng buá»™c:**

* `1 <= Number of nodes <= 10^5`
* `-10^4 <= Node.val <= 10^4`

***

## **ğŸ’¡ VÃ­ dá»¥**

#### âœ… **VÃ­ dá»¥ 1**

```
Input: root = [3,1,4,3,null,1,5]
Output: 4
```

**Giáº£i thÃ­ch:**\
CÃ¢y nhá»‹ phÃ¢n:

```
        3
       / \
      1   4
     /   / \
    3   1   5
```

* **Good nodes:** `3` (root), `3` (left), `4` (right), `5` (right-right).\
  âœ… **Tá»•ng sá»‘ Good nodes = 4**

***

#### âœ… **VÃ­ dá»¥ 2**

```
Input: root = [3,3,null,4,2]
Output: 3
```

```
       3
      / 
     3   
    / \
   4   2
```

* **Good nodes:** `3` (root), `3` (left), `4` (left-left).\
  âœ… **Tá»•ng sá»‘ Good nodes = 3**

***

## **ğŸš€ Giáº£i phÃ¡p: DFS - Duyá»‡t cÃ¢y & Kiá»ƒm tra max Ä‘Æ°á»ng Ä‘i**

#### ğŸ“Œ **Ã tÆ°á»Ÿng chÃ­nh:**

* Duyá»‡t cÃ¢y theo **DFS** (Ä‘á»‡ quy hoáº·c stack).
* LÆ°u **giÃ¡ trá»‹ lá»›n nháº¥t** trÃªn Ä‘Æ°á»ng Ä‘i Ä‘áº¿n má»—i node (`maxSoFar`).
* Náº¿u `node.val >= maxSoFar`, thÃ¬ node Ä‘Ã³ lÃ  **good node**.
* Cáº­p nháº­t `maxSoFar` khi Ä‘i xuá»‘ng con.

âœ… **Äá»™ phá»©c táº¡p:** `O(n)` (má»—i node Ä‘Æ°á»£c duyá»‡t Ä‘Ãºng 1 láº§n).\
âœ… **KhÃ´ng gian:** `O(h)` vá»›i `h` lÃ  chiá»u cao cÃ¢y (stack Ä‘á»‡ quy).

***

## **ğŸ“œ Code**

{% tabs %}
{% tab title="C++" %}
```cpp
class Solution {
public:
    int goodNodes(TreeNode* root, int maxSoFar = INT_MIN) {
        if (!root) return 0;
        int count = root->val >= maxSoFar ? 1 : 0;
        maxSoFar = max(maxSoFar, root->val);
        return count + goodNodes(root->left, maxSoFar) + goodNodes(root->right, maxSoFar);
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
class Solution {
    public int goodNodes(TreeNode root) {
        return dfs(root, Integer.MIN_VALUE);
    }
    
    private int dfs(TreeNode node, int maxSoFar) {
        if (node == null) return 0;
        
        int count = node.val >= maxSoFar ? 1 : 0;
        maxSoFar = Math.max(maxSoFar, node.val);
        
        count += dfs(node.left, maxSoFar);
        count += dfs(node.right, maxSoFar);
        
        return count;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        def dfs(node, max_so_far):
            if not node:
                return 0
            count = 1 if node.val >= max_so_far else 0
            max_so_far = max(max_so_far, node.val)
            return count + dfs(node.left, max_so_far) + dfs(node.right, max_so_far)
        
        return dfs(root, float('-inf'))
```
{% endtab %}
{% endtabs %}

***

## **â³ Äá»™ phá»©c táº¡p thuáº­t toÃ¡n**

| PhÆ°Æ¡ng phÃ¡p      | Thá»i gian | KhÃ´ng gian |
| ---------------- | --------- | ---------- |
| **DFS (Äá»‡ quy)** | `O(n)`    | `O(h)`     |

âœ… **Duyá»‡t cÃ¢y chá»‰ má»™t láº§n â†’ O(n)**\
âœ… **Stack Ä‘á»‡ quy tá»‘i Ä‘a `O(h)`, vá»›i `h` lÃ  chiá»u cao cÃ¢y**

***

## **ğŸ“Œ Tá»•ng káº¿t**

âœ” **DÃ¹ng DFS Ä‘á»ƒ duyá»‡t cÃ¢y vÃ  kiá»ƒm tra giÃ¡ trá»‹ lá»›n nháº¥t trÃªn Ä‘Æ°á»ng Ä‘i.**\
âœ” **Má»—i node chá»‰ cáº§n duyá»‡t má»™t láº§n â†’ O(n).**\
âœ” **á»¨ng dá»¥ng:** Äáº¿m sá»‘ lÆ°á»£ng node Ä‘áº·c biá»‡t trong cÃ¢y.
