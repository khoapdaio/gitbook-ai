# 790. Domino and Tromino Tiling

## **❓ Problem:**&#x20;

[Leetcode 790 - Domino and Tromino Tiling](https://leetcode.com/problems/domino-and-tromino-tiling)

## **📝 Mô tả:**

Bạn có một lưới 2 x `n`. Có hai loại miếng ghép:

* **Domino** (kích thước 2x1)
* **Tromino** (hình chữ "L", chiếm 3 ô)

Hãy tìm số cách xếp các miếng ghép này để **lấp đầy hoàn toàn** lưới 2 x `n`.

Kết quả trả về **modulo** `10^9 + 7`.

***

## **💡 Ví dụ**

#### **✅ Ví dụ 1:**

**Input:**

```plaintext
n = 3
```

**Output:**

```plaintext
5
```

**Giải thích:**\
Có 5 cách xếp hợp lệ:

1. Ba miếng **domino** dọc.
2. Hai miếng **domino** ngang, một miếng **domino** dọc.
3. Một miếng **tromino** + một miếng **domino**.
4. Một miếng **tromino** khác kiểu + một miếng **domino**.
5. Một miếng **tromino** + một miếng **tromino** ngược.

#### **✅ Ví dụ 2:**

**Input:**

```plaintext
n = 1
```

**Output:**

```plaintext
1
```

**Giải thích:**

* Chỉ có một cách là **đặt một domino dọc**.

***

## **🚀 Giải pháp 1: Dynamic Programming (Quy hoạch động)**

#### **🔹Ý tưởng:**

* Gọi `dp[i]` là số cách xếp đầy lưới **2 x i**.
* Ta có công thức truy hồi: dp\[i]=dp\[i−1]+dp\[i−2]+2×sum\[i−3]dp\[i] = dp\[i-1] + dp\[i-2] + 2 \times sum\[i-3]dp\[i]=dp\[i−1]+dp\[i−2]+2×sum\[i−3] Trong đó `sum[i]` là tổng `dp[0]` đến `dp[i]`.

***

### **📜 Code**

{% tabs %}
{% tab title="C++" %}
```cpp
class Solution {
public:
    int numTilings(int n) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        if (n == 3) return 5;

        const int MOD = 1e9 + 7;
        vector<long long> dp(n + 1, 0);
        dp[1] = 1; dp[2] = 2; dp[3] = 5;

        for (int i = 4; i <= n; ++i) {
            dp[i] = (2 * dp[i - 1] + dp[i - 3]) % MOD;
        }

        return dp[n];
    }
};

```
{% endtab %}

{% tab title="Java" %}
```java
class Solution {
    public int numTilings(int n) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        if (n == 3) return 5;

        final int MOD = 1_000_000_007;
        long[] dp = new long[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 5;

        for (int i = 4; i <= n; ++i) {
            dp[i] = (2 * dp[i - 1] + dp[i - 3]) % MOD;
        }

        return (int) dp[n];
    }
}

```
{% endtab %}

{% tab title="Python" %}
```python
class Solution:
    def numTilings(self, n: int) -> int:
        if n <= 2:
            return n

        MOD = 10**9 + 7
        dp = [0] * (n + 1)
        dp[0], dp[1], dp[2] = 1, 1, 2

        for i in range(3, n + 1):
            dp[i] = (dp[i - 1] + dp[i - 2] + 2 * dp[i - 3]) % MOD
        
        return dp[n]
```
{% endtab %}
{% endtabs %}

***

## **🚀 Giải pháp 2: Tối ưu bộ nhớ (O(1) Space)**

#### **🔹Ý tưởng:**

* **Chỉ cần lưu ba giá trị gần nhất** thay vì lưu toàn bộ mảng `dp`.
* Dùng biến `prev3, prev2, prev1, curr` để lưu trạng thái.

***

### **📜 Code**

{% tabs %}
{% tab title="C++" %}
```cpp
class Solution {
public:
    int numTilings(int n) {
        if (n <= 2) return n;

        int MOD = 1e9 + 7;
        long long prev3 = 1, prev2 = 1, prev1 = 2, curr = 0;

        for (int i = 3; i <= n; i++) {
            curr = (prev1 + prev2 + 2 * prev3) % MOD;
            prev3 = prev2;
            prev2 = prev1;
            prev1 = curr;
        }

        return curr;
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
class Solution {
    public int numTilings(int n) {
        if (n <= 2) return n;

        int MOD = 1000000007;
        long prev3 = 1, prev2 = 1, prev1 = 2, curr = 0;

        for (int i = 3; i <= n; i++) {
            curr = (prev1 + prev2 + 2 * prev3) % MOD;
            prev3 = prev2;
            prev2 = prev1;
            prev1 = curr;
        }

        return (int) curr;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
class Solution:
    def numTilings(self, n: int) -> int:
        if n <= 2:
            return n

        MOD = 10**9 + 7
        prev3, prev2, prev1 = 1, 1, 2

        for _ in range(3, n + 1):
            curr = (prev1 + prev2 + 2 * prev3) % MOD
            prev3, prev2, prev1 = prev2, prev1, curr
        
        return prev1
```
{% endtab %}
{% endtabs %}

***

## **🎯 Điểm chính**

✔ **Dùng quy hoạch động để tối ưu số cách xếp**.\
✔ **Tối ưu bộ nhớ bằng cách chỉ giữ 3 giá trị gần nhất**.\
✔ **Sử dụng `modulo 10^9 + 7` để tránh số quá lớn**.

***

## **⏳ Độ phức tạp thuật toán**

| Phương pháp               | Độ phức tạp | Bộ nhớ |
| ------------------------- | ----------- | ------ |
| **DP (`O(n) Space`)**     | `O(n)`      | `O(n)` |
| **Tối ưu (`O(1) Space`)** | `O(n)`      | `O(1)` |

***

## **📌 Tổng kết**

🔹 Đây là bài toán **quy hoạch động nâng cao**.\
🔹 **Giải pháp `O(1) Space`** giúp tiết kiệm bộ nhớ.\
🔹 Áp dụng cho các bài toán **xếp hình, Fibonacci mở rộng** 🚀
