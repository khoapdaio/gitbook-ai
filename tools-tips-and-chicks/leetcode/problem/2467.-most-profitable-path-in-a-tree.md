# 2467. Most Profitable Path in a Tree

## **â“ Problem:**&#x20;

[Leetcode: 2467. Most Profitable Path in a Tree](https://leetcode.com/problems/most-profitable-path-in-a-tree)

## **ğŸ“ MÃ´ táº£:**

Cho má»™t **cÃ¢y** cÃ³ `n` nÃºt Ä‘Æ°á»£c biá»ƒu diá»…n báº±ng danh sÃ¡ch cáº¡nh `edges`, trong Ä‘Ã³ `edges[i] = [ui, vi]` nghÄ©a lÃ  cÃ³ cáº¡nh giá»¯a `ui` vÃ  `vi`. NÃºt `0` lÃ  **gá»‘c cÃ¢y**.\
Má»—i nÃºt cÃ³ má»™t sá»‘ tiá»n `amount[i]`, cÃ³ thá»ƒ dÆ°Æ¡ng hoáº·c Ã¢m.

CÃ³ hai ngÆ°á»i chÆ¡i:

1. **Alice** báº¯t Ä‘áº§u tá»« `node 0`, cÃ³ thá»ƒ **Ä‘i báº¥t ká»³ hÆ°á»›ng nÃ o**.
2. **Bob** báº¯t Ä‘áº§u tá»« `bob`, chá»‰ cÃ³ thá»ƒ **di chuyá»ƒn vá» gá»‘c `0`**.

* Náº¿u Alice vÃ  Bob gáº·p nhau láº§n Ä‘áº§u tiÃªn táº¡i cÃ¹ng má»™t nÃºt, **Alice chá»‰ láº¥y Ä‘Æ°á»£c má»™t ná»­a sá»‘ tiá»n** á»Ÿ nÃºt Ä‘Ã³.
* Alice muá»‘n tÃ¬m **Ä‘Æ°á»ng Ä‘i nÃ o giÃºp tá»‘i Ä‘a hÃ³a tá»•ng sá»‘ tiá»n cÃ´ áº¥y cÃ³ thá»ƒ láº¥y**.

**YÃªu cáº§u:** Tráº£ vá» **lá»£i nhuáº­n tá»‘i Ä‘a mÃ  Alice cÃ³ thá»ƒ láº¥y**.

***

## **ğŸ’¡ VÃ­ dá»¥:**

#### âœ… **VÃ­ dá»¥ 1:**

**Input:**

```cpp
edges = [[0,1],[1,2],[1,3],[3,4]]
bob = 3
amount = [-2,4,2,-4,6]
```

**Output:**

```cpp
6
```

**Giáº£i thÃ­ch:**

```
- Bob Ä‘i tá»« node `3` -> `1` -> `0`
- Alice Ä‘i theo Ä‘Æ°á»ng tá»‘t nháº¥t Ä‘á»ƒ láº¥y tiá»n tá»‘i Ä‘a.
- Lá»£i nhuáº­n tá»‘i Ä‘a mÃ  Alice cÃ³ thá»ƒ láº¥y lÃ  `6`.
```

#### âœ… **VÃ­ dá»¥ 2:**

**Input:**

```cpp
edges = [[0,1]]
bob = 1
amount = [-2,4]
```

**Output:**

```cpp
cppSao chÃ©pChá»‰nh sá»­a2
```

**Giáº£i thÃ­ch:**

```
- Alice chá»‰ cÃ³ thá»ƒ Ä‘i Ä‘áº¿n node `1` vÃ  láº¥y `amount[1] = 4`
- Bob cÅ©ng Ä‘áº¿n node `1`, nÃªn Alice chá»‰ láº¥y Ä‘Æ°á»£c `4/2 = 2`
```

***

## **ğŸš€ Giáº£i phÃ¡p: DFS + Backtracking**

#### **ğŸ”¹ Ã tÆ°á»Ÿng:**

1. **XÃ¢y dá»±ng cÃ¢y dÆ°á»›i dáº¡ng danh sÃ¡ch ká»**.
2. **TÃ¬m Ä‘Æ°á»ng Ä‘i ngáº¯n nháº¥t cá»§a Bob vá» gá»‘c `0`**, lÆ°u thá»i gian Bob Ä‘áº¿n má»—i nÃºt.
3. **DÃ¹ng DFS cho Alice Ä‘á»ƒ tÃ¬m lá»£i nhuáº­n tá»‘i Ä‘a**:
   * Náº¿u Alice gáº·p Bob táº¡i cÃ¹ng má»™t nÃºt **láº§n Ä‘áº§u tiÃªn**, Alice chá»‰ láº¥y **ná»­a tiá»n**.
   * Náº¿u Alice Ä‘áº¿n **sau Bob**, Alice khÃ´ng láº¥y Ä‘Æ°á»£c tiá»n á»Ÿ nÃºt Ä‘Ã³, khÃ´ng tÃ­nh láº§n bÆ°á»›c Ä‘áº¿n Ä‘Ã³.
   * Chá»n Ä‘Æ°á»ng Ä‘i tá»‘i Æ°u Ä‘á»ƒ tá»‘i Ä‘a hÃ³a tá»•ng tiá»n.

***

## **ğŸ“œ Code:**

{% tabs %}
{% tab title="C++" %}
```cpp
#include <vector>
#include <climits>
using namespace std;

class Solution {
public:
    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {
        int n = amount.size();
        vector<vector<int>> graph(n);
        
        // XÃ¢y dá»±ng danh sÃ¡ch ká»
        for (const auto& edge : edges) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }

        vector<int> bobArrival(n, INT_MAX);
        
        // DFS Bob Ä‘á»ƒ xÃ¡c Ä‘á»‹nh thá»i gian Ä‘áº¿n má»—i node
        dfsBob(bob, -1, 0, graph, bobArrival);

        // DFS Alice Ä‘á»ƒ tÃ¬m lá»£i nhuáº­n tá»‘i Ä‘a
        return dfsAlice(0, -1, 0, 0, graph, bobArrival, amount);
    }

private:
    bool dfsBob(int node, int parent, int time, vector<vector<int>>& graph, vector<int>& bobArrival) {
        bobArrival[node] = time;
        if (node == 0) return true; // Bob Ä‘Ã£ Ä‘áº¿n node 0

        for (int neighbor : graph[node]) {
            if (neighbor != parent && dfsBob(neighbor, node, time + 1, graph, bobArrival)) {
                return true;
            }
        }

        // Náº¿u Bob khÃ´ng Ä‘áº¿n node 0 tá»« nhÃ¡nh nÃ y, Ä‘áº·t láº¡i thá»i gian
        bobArrival[node] = INT_MAX;
        return false;
    }

    int dfsAlice(int node, int parent, int time, int currentProfit, 
                 vector<vector<int>>& graph, vector<int>& bobArrival, vector<int>& amount) {
        if (time < bobArrival[node]) {
            currentProfit += amount[node]; // Alice Ä‘áº¿n trÆ°á»›c Bob
        } else if (time == bobArrival[node]) {
            currentProfit += amount[node] / 2; // Alice vÃ  Bob Ä‘áº¿n cÃ¹ng lÃºc
        }

        int maxProfit = INT_MIN;
        bool isLeaf = true;

        for (int neighbor : graph[node]) {
            if (neighbor != parent) {
                isLeaf = false;
                maxProfit = max(maxProfit, dfsAlice(neighbor, node, time + 1, currentProfit, graph, bobArrival, amount));
            }
        }

        return isLeaf ? currentProfit : maxProfit;
    }
};

```
{% endtab %}

{% tab title="Java" %}
```java
import java.util.*;

class Solution {
    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {
        int n = amount.length;
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());

        // XÃ¢y dá»±ng Ä‘á»“ thá»‹ dáº¡ng danh sÃ¡ch ká»
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1];
            graph.get(u).add(v);
            graph.get(v).add(u);
        }

        int[] bobArrival = new int[n];
        Arrays.fill(bobArrival, Integer.MAX_VALUE);

        // DFS Bob: XÃ¡c Ä‘á»‹nh thá»i gian Bob Ä‘áº¿n má»—i node
        if (!dfsBob(bob, -1, 0, graph, bobArrival)) return 0;

        // DFS Alice: TÃ¬m lá»£i nhuáº­n tá»‘i Ä‘a
        return dfsAlice(0, -1, 0, 0, graph, bobArrival, amount);
    }

    private boolean dfsBob(int node, int parent, int time, List<List<Integer>> graph, int[] bobArrival) {
        bobArrival[node] = time;
        if (node == 0) return true; // Bob Ä‘Ã£ Ä‘áº¿n node 0

        for (int neighbor : graph.get(node)) {
            if (neighbor != parent && dfsBob(neighbor, node, time + 1, graph, bobArrival)) {
                return true;
            }
        }

        // Náº¿u Bob khÃ´ng Ä‘áº¿n node 0 tá»« Ä‘Æ°á»ng nÃ y, Ä‘áº·t láº¡i thá»i gian vá» MAX_VALUE
        bobArrival[node] = Integer.MAX_VALUE;
        return false;
    }

    private int dfsAlice(int node, int parent, int time, int currentProfit,
                         List<List<Integer>> graph, int[] bobArrival, int[] amount) {
        if (time < bobArrival[node]) {
            currentProfit += amount[node]; // Alice Ä‘áº¿n trÆ°á»›c Bob
        } else if (time == bobArrival[node]) {
            currentProfit += amount[node] / 2; // Alice vÃ  Bob Ä‘áº¿n cÃ¹ng lÃºc
        }

        int maxProfit = Integer.MIN_VALUE;
        boolean isLeaf = true;

        for (int neighbor : graph.get(node)) {
            if (neighbor != parent) {
                isLeaf = false;
                maxProfit = Math.max(maxProfit, dfsAlice(neighbor, node, time + 1, currentProfit, graph, bobArrival, amount));
            }
        }

        // Náº¿u lÃ  lÃ¡, cáº­p nháº­t maxProfit
        return isLeaf ? currentProfit : maxProfit;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
from typing import List
import math

class Solution:
    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        n = len(amount)
        graph = [[] for _ in range(n)]
        
        # XÃ¢y dá»±ng danh sÃ¡ch ká»
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        bobArrival = [math.inf] * n
        
        # DFS Bob Ä‘á»ƒ xÃ¡c Ä‘á»‹nh thá»i gian Ä‘áº¿n má»—i node
        def dfsBob(node, parent, time):
            bobArrival[node] = time
            if node == 0:
                return True
            for neighbor in graph[node]:
                if neighbor != parent and dfsBob(neighbor, node, time + 1):
                    return True
            bobArrival[node] = math.inf
            return False
        
        dfsBob(bob, -1, 0)

        # DFS Alice Ä‘á»ƒ tÃ¬m lá»£i nhuáº­n tá»‘i Ä‘a
        def dfsAlice(node, parent, time, currentProfit):
            if time < bobArrival[node]:
                currentProfit += amount[node]  # Alice Ä‘áº¿n trÆ°á»›c Bob
            elif time == bobArrival[node]:
                currentProfit += amount[node] // 2  # Alice vÃ  Bob Ä‘áº¿n cÃ¹ng lÃºc
            
            isLeaf = True
            maxProfit = -math.inf

            for neighbor in graph[node]:
                if neighbor != parent:
                    isLeaf = False
                    maxProfit = max(maxProfit, dfsAlice(neighbor, node, time + 1, currentProfit))
            
            return currentProfit if isLeaf else maxProfit

        return dfsAlice(0, -1, 0, 0)

```
{% endtab %}
{% endtabs %}

***

## **ğŸ¯ Äiá»ƒm chÃ­nh:**

âœ… **Sá»­ dá»¥ng DFS + Backtracking** Ä‘á»ƒ tÃ¬m lá»£i nhuáº­n tá»‘i Ä‘a.\
âœ… **TÃ­nh toÃ¡n trÆ°á»›c thá»i gian Bob Ä‘áº¿n tá»«ng nÃºt**.\
âœ… **Xá»­ lÃ½ Alice vá»›i lá»£i nhuáº­n tá»‘i Ä‘a báº±ng cÃ¡ch DFS**.

## **â³ Äá»™ phá»©c táº¡p thuáº­t toÃ¡n:**

* **Duyá»‡t cÃ¢y**: `O(N)`.
* **DFS Ä‘á»ƒ tá»‘i Æ°u lá»£i nhuáº­n**: `O(N)`.
* **Tá»•ng cá»™ng**: `O(N)`.

## **ğŸ“Œ Tá»•ng káº¿t:**

* **DÃ¹ng DFS Ä‘á»ƒ tÃ¬m Ä‘Æ°á»ng Bob Ä‘i trÆ°á»›c**.
* **DFS tá»‘i Æ°u hÃ³a lá»£i nhuáº­n Alice cÃ³ thá»ƒ nháº­n Ä‘Æ°á»£c**. ğŸš€
