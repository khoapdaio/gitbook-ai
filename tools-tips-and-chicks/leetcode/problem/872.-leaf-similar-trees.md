# 872. Leaf-Similar Trees

## Problem

[https://leetcode.com/problems/leaf-similar-trees](https://leetcode.com/problems/leaf-similar-trees)

***

## **üìå M√¥ t·∫£ b√†i to√°n**

Hai c√¢y nh·ªã ph√¢n ƒë∆∞·ª£c g·ªçi l√† **leaf-similar** n·∫øu d√£y c√°c l√° c·ªßa ch√∫ng theo th·ª© t·ª± **gi·ªëng nhau**.

* Cho hai c√¢y `root1` v√† `root2`, ki·ªÉm tra xem **ch√∫ng c√≥ leaf-similar hay kh√¥ng**.
* **Node l√°** l√† node **kh√¥ng c√≥ con tr√°i v√† con ph·∫£i**.

üìå **R√†ng bu·ªôc:**

* `1 <= Number of nodes in each tree <= 200`
* `0 <= Node.val <= 200`

***

## **üí° V√≠ d·ª•**

#### ‚úÖ **V√≠ d·ª• 1**

```
Input: root1 = [3,5,1,6,2,9,8,null,null,7,4], 
       root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
Output: true
```

**Gi·∫£i th√≠ch:**\
Hai c√¢y:

```
        3                    3
       / \                  / \
      5   1                5   1
     / \ / \              / \ / \
    6  2 9  8            6  7 4  2
      / \                      / \
     7   4                    9   8
```

* **L√° c·ªßa c√¢y 1**: `[6,7,4,9,8]`
* **L√° c·ªßa c√¢y 2**: `[6,7,4,9,8]`\
  ‚úÖ **K·∫øt qu·∫£:** `true` (V√¨ d√£y l√° gi·ªëng nhau).

***

#### ‚úÖ **V√≠ d·ª• 2**

```
Input: root1 = [1,2,3], root2 = [1,3,2]
Output: false
```

**Gi·∫£i th√≠ch:**

```
    1        1
   / \      / \
  2   3    3   2
```

* **L√° c·ªßa c√¢y 1**: `[2,3]`
* **L√° c·ªßa c√¢y 2**: `[3,2]`\
  üö´ **D√£y l√° kh√°c nhau ‚Üí K·∫øt qu·∫£ l√† `false`**

***

## **üöÄ Gi·∫£i ph√°p: Duy·ªát c√¢y & So s√°nh danh s√°ch l√°**

#### üìå **√ù t∆∞·ªüng ch√≠nh:**

1. **Duy·ªát c√¢y theo DFS (Depth-First Search)** ƒë·ªÉ thu th·∫≠p danh s√°ch c√°c l√°.
2. So s√°nh danh s√°ch l√° c·ªßa hai c√¢y.
3. N·∫øu gi·ªëng nhau ‚Üí Tr·∫£ v·ªÅ `true`, ng∆∞·ª£c l·∫°i `false`.

‚úÖ **ƒê·ªô ph·ª©c t·∫°p:** `O(n + m)`, v·ªõi `n` v√† `m` l√† s·ªë node c·ªßa hai c√¢y.\
‚úÖ **Kh√¥ng gian:** `O(h1 + h2)` v·ªõi `h1, h2` l√† chi·ªÅu cao c·ªßa c√¢y (stack ƒë·ªá quy).

***

## **üìú Code**

{% tabs %}
{% tab title="C++" %}
```cpp
#include <vector>

class Solution {
public:
    bool leafSimilar(TreeNode* root1, TreeNode* root2) {
        vector<int> leaves1, leaves2;
        getLeaves(root1, leaves1);
        getLeaves(root2, leaves2);
        return leaves1 == leaves2;
    }
    
    void getLeaves(TreeNode* node, vector<int>& leaves) {
        if (!node) return;
        if (!node->left && !node->right) {
            leaves.push_back(node->val);
        }
        getLeaves(node->left, leaves);
        getLeaves(node->right, leaves);
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
import java.util.*;

class Solution {
    public boolean leafSimilar(TreeNode root1, TreeNode root2) {
        List<Integer> leaves1 = new ArrayList<>();
        List<Integer> leaves2 = new ArrayList<>();
        
        getLeaves(root1, leaves1);
        getLeaves(root2, leaves2);
        
        return leaves1.equals(leaves2);
    }

    private void getLeaves(TreeNode node, List<Integer> leaves) {
        if (node == null) return;
        if (node.left == null && node.right == null) {
            leaves.add(node.val);
        }
        getLeaves(node.left, leaves);
        getLeaves(node.right, leaves);
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
class Solution:
    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:
        def get_leaves(node):
            if not node:
                return []
            if not node.left and not node.right:
                return [node.val]
            return get_leaves(node.left) + get_leaves(node.right)
        
        return get_leaves(root1) == get_leaves(root2)
```
{% endtab %}
{% endtabs %}

***

## **‚è≥ ƒê·ªô ph·ª©c t·∫°p thu·∫≠t to√°n**

| Ph∆∞∆°ng ph√°p      | Th·ªùi gian  | Kh√¥ng gian   |
| ---------------- | ---------- | ------------ |
| **DFS (ƒê·ªá quy)** | `O(n + m)` | `O(h1 + h2)` |

‚úÖ **DFS gi√∫p t√¨m danh s√°ch l√° nhanh ch√≥ng, ch·ªâ duy·ªát m·ªói node m·ªôt l·∫ßn.**\
‚úÖ **Kh√¥ng gian `O(h)` (h = chi·ªÅu cao c√¢y), ph√π h·ª£p v·ªõi c√¢y c√¢n b·∫±ng.**

***

## **üìå T·ªïng k·∫øt**

‚úî **D√πng DFS ƒë·ªÉ thu th·∫≠p danh s√°ch l√° c·ªßa m·ªói c√¢y.**\
‚úî **So s√°nh hai danh s√°ch ƒë·ªÉ x√°c ƒë·ªãnh xem c√¢y c√≥ "leaf-similar" kh√¥ng.**\
‚úî **·ª®ng d·ª•ng:** Ki·ªÉm tra t∆∞∆°ng ƒë·ªìng c·ªßa hai c√¢y nh·ªã ph√¢n theo l√°.
