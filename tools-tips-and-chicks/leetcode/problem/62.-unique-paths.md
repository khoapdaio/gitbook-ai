# 62. Unique Paths

## **â“ Problem**

ğŸ”—[Leetcode: 62. Unique Paths](https://leetcode.com/problems/unique-paths)

## **ğŸ“ MÃ´ táº£**

Má»™t robot báº¯t Ä‘áº§u tá»« Ã´ **trÃªn cÃ¹ng bÃªn trÃ¡i** cá»§a lÆ°á»›i `m x n`. Robot chá»‰ cÃ³ thá»ƒ di chuyá»ƒn **xuá»‘ng dÆ°á»›i** hoáº·c **sang pháº£i** táº¡i má»—i bÆ°á»›c.\
Robot cáº§n Ä‘áº¿n Ä‘Æ°á»£c Ã´ **dÆ°á»›i cÃ¹ng bÃªn pháº£i**. HÃ£y tÃ­nh sá»‘ cÃ¡ch di chuyá»ƒn há»£p lá»‡ tá»« Ä‘iá»ƒm xuáº¥t phÃ¡t Ä‘áº¿n Ä‘iá»ƒm Ä‘Ã­ch.

## **ğŸ’¡ VÃ­ dá»¥**

#### âœ… VÃ­ dá»¥ 1:

**Input:**

```plaintext
m = 3, n = 7
```

**Output:**

```plaintext
28
```

***

#### âœ… VÃ­ dá»¥ 2:

**Input:**

```plaintext
m = 3, n = 2
```

**Output:**

```plaintext
3
```

**Giáº£i thÃ­ch:**

1. Äi xuá»‘ng, Ä‘i xuá»‘ng, Ä‘i pháº£i.
2. Äi xuá»‘ng, Ä‘i pháº£i, Ä‘i xuá»‘ng.
3. Äi pháº£i, Ä‘i xuá»‘ng, Ä‘i xuá»‘ng.

***

## **ğŸš€ Giáº£i phÃ¡p 1: Quy hoáº¡ch Ä‘á»™ng (Dynamic Programming)**

ChÃºng ta sá»­ dá»¥ng quy hoáº¡ch Ä‘á»™ng vá»›i cÃ´ng thá»©c:

$$
dp[i][j] = dp[i-1][j] + dp[i][j-1]
$$

Vá»›i `dp[i][j]` lÃ  sá»‘ cÃ¡ch Ä‘á»ƒ Ä‘áº¿n Ã´ `(i, j)`.

### **ğŸ“œ Code**

{% tabs %}
{% tab title="C++" %}
```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 1));

        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];

        for (int i = 0; i < m; i++) {
            Arrays.fill(dp[i], 1);
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m - 1][n - 1];
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[1] * n for _ in range(m)]

        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]

        return dp[m - 1][n - 1]
```
{% endtab %}
{% endtabs %}

***

## **ğŸš€ Giáº£i phÃ¡p 2: ToÃ¡n há»c (Tá»• há»£p)**

Má»™t cÃ¡ch khÃ¡c Ä‘á»ƒ giáº£i quyáº¿t váº¥n Ä‘á» nÃ y lÃ  sá»­ dá»¥ng tá»• há»£p.\
Sá»‘ bÆ°á»›c cáº§n Ä‘i lÃ  `(m-1)` xuá»‘ng vÃ  `(n-1)` sang pháº£i, tá»•ng sá»‘ bÆ°á»›c lÃ  `(m+n-2)`.\
ChÃºng ta chá»n `(m-1)` bÆ°á»›c xuá»‘ng trong tá»•ng `(m+n-2)` bÆ°á»›c:

$$
dp[i][j] = dp[i-1][j] + dp[i][j-1]
$$

### **ğŸ“œ Code**

{% tabs %}
{% tab title="C++" %}
```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        long res = 1;
        for (int i = 1; i <= m - 1; i++) {
            res = res * (n - 1 + i) / i;
        }
        return (int)res;
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
class Solution {
    public int uniquePaths(int m, int n) {
        long res = 1;
        for (int i = 1; i < m; i++) {
            res = res * (n - 1 + i) / i;
        }
        return (int) res;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
import math

class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        return math.comb(m + n - 2, m - 1)
```
{% endtab %}
{% endtabs %}

***

## **ğŸ¯ Äiá»ƒm chÃ­nh**

* **Giáº£i phÃ¡p DP** phÃ¹ há»£p khi `m, n` khÃ´ng quÃ¡ lá»›n do cáº§n `O(m*n)` bá»™ nhá»›.
* **Giáº£i phÃ¡p tá»• há»£p** cÃ³ Ä‘á»™ phá»©c táº¡p tá»‘t hÆ¡n `O(min(m, n))` vÃ  khÃ´ng cáº§n máº£ng lÆ°u trá»¯.

***

## **â³ Äá»™ phá»©c táº¡p**

| Giáº£i phÃ¡p | Thá»i gian    | KhÃ´ng gian |
| --------- | ------------ | ---------- |
| DP        | O(m\*n)      | O(m\*n)    |
| Tá»• há»£p    | O(min(m, n)) | O(1)       |

***

## **ğŸ“Œ Tá»•ng káº¿t**

* **DP**: Trá»±c quan, dá»… hiá»ƒu nhÆ°ng tá»‘n bá»™ nhá»›.
* **Tá»• há»£p**: Hiá»‡u quáº£ hÆ¡n vá» khÃ´ng gian, tá»‘c Ä‘á»™ nhanh hÆ¡n.
* Náº¿u cáº§n tá»‘i Æ°u, **giáº£i phÃ¡p tá»• há»£p** lÃ  lá»±a chá»n tá»‘t nháº¥t! ğŸš€
