# 1679. Max Number of K-Sum Pairs

## Problem

[https://leetcode.com/problems/max-number-of-k-sum-pairs/](https://leetcode.com/problems/max-number-of-k-sum-pairs/)

## **M√¥ t·∫£**

Cho m·ªôt m·∫£ng s·ªë nguy√™n `nums[]` v√† m·ªôt s·ªë nguy√™n `k`, t√¨m **s·ªë l∆∞·ª£ng c·∫∑p (i, j)** sao cho:

* `nums[i] + nums[j] == k`
* `i ‚â† j` (m·ªói ph·∫ßn t·ª≠ ch·ªâ ƒë∆∞·ª£c d√πng m·ªôt l·∫ßn)

***

## **V√≠ d·ª•**

**‚úÖ V√≠ d·ª• 1**

```
textSao ch√©pCh·ªânh s·ª≠aInput: nums = [1,2,3,4], k = 5
Output: 2
```

**Gi·∫£i th√≠ch:** Hai c·∫∑p `(1,4)` v√† `(2,3)` c√≥ t·ªïng b·∫±ng `5`.

**‚úÖ V√≠ d·ª• 2**

```
textSao ch√©pCh·ªânh s·ª≠aInput: nums = [3,1,3,4,3], k = 6
Output: 1
```

**Gi·∫£i th√≠ch:** Ch·ªâ c√≥ th·ªÉ gh√©p m·ªôt c·∫∑p `(3,3)`.

***

## **Gi·∫£i ph√°p 1: D√πng HashMap (`O(n)`)**

üìå **√ù t∆∞·ªüng:**

* Duy·ªát qua `nums`, d√πng **HashMap** `freq` ƒë·ªÉ l∆∞u t·∫ßn su·∫•t xu·∫•t hi·ªán c·ªßa t·ª´ng s·ªë.
* V·ªõi m·ªói s·ªë `num`, ki·ªÉm tra xem `k - num` ƒë√£ xu·∫•t hi·ªán ch∆∞a.
* N·∫øu c√≥, tƒÉng s·ªë c·∫∑p v√† gi·∫£m s·ªë l∆∞·ª£ng c·ªßa `k - num`.

***

## **Code**

{% tabs %}
{% tab title="C++" %}
```cpp
#include <unordered_map>
#include <vector>
using namespace std;

class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        unordered_map<int, int> freq;
        int count = 0;

        for (int num : nums) {
            int complement = k - num;

            if (freq[complement] > 0) {
                count++;
                freq[complement]--;
            } else {
                freq[num]++;
            }
        }

        return count;
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
import java.util.HashMap;

class Solution {
    public int maxOperations(int[] nums, int k) {
        HashMap<Integer, Integer> freq = new HashMap<>();
        int count = 0;

        for (int num : nums) {
            int complement = k - num;

            if (freq.getOrDefault(complement, 0) > 0) {
                count++;
                freq.put(complement, freq.get(complement) - 1);
            } else {
                freq.put(num, freq.getOrDefault(num, 0) + 1);
            }
        }

        return count;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
from collections import Counter

class Solution:
    def maxOperations(self, nums: List[int], k: int) -> int:
        freq = Counter()
        count = 0

        for num in nums:
            complement = k - num
            if freq[complement] > 0:
                count += 1
                freq[complement] -= 1
            else:
                freq[num] += 1

        return count
```
{% endtab %}
{% endtabs %}



***

## **Gi·∫£i ph√°p 2: D√πng hai con tr·ªè (`O(n log n)`)**

üìå **√ù t∆∞·ªüng:**

* **S·∫Øp x·∫øp `nums`**.
* D√πng hai con tr·ªè `left, right` ƒë·ªÉ t√¨m c·∫∑p c√≥ t·ªïng `k`.
* N·∫øu `nums[left] + nums[right] == k` ‚Üí TƒÉng s·ªë c·∫∑p, di chuy·ªÉn `left++`, `right--`.

***

## **Code**

{% tabs %}
{% tab title="C++" %}
```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int left = 0, right = nums.size() - 1;
        int count = 0;

        while (left < right) {
            int sum = nums[left] + nums[right];

            if (sum == k) {
                count++;
                left++;
                right--;
            } else if (sum < k) {
                left++;
            } else {
                right--;
            }
        }

        return count;
    }
};
```


{% endtab %}

{% tab title="Java" %}
```java
import java.util.Arrays;

class Solution {
    public int maxOperations(int[] nums, int k) {
        Arrays.sort(nums);
        int left = 0, right = nums.length - 1;
        int count = 0;

        while (left < right) {
            int sum = nums[left] + nums[right];

            if (sum == k) {
                count++;
                left++;
                right--;
            } else if (sum < k) {
                left++;
            } else {
                right--;
            }
        }

        return count;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
class Solution:
    def maxOperations(self, nums: List[int], k: int) -> int:
        nums.sort()
        left, right = 0, len(nums) - 1
        count = 0

        while left < right:
            sum_ = nums[left] + nums[right]

            if sum_ == k:
                count += 1
                left += 1
                right -= 1
            elif sum_ < k:
                left += 1
            else:
                right -= 1

        return count
```
{% endtab %}
{% endtabs %}

***

## **ƒê·ªô ph·ª©c t·∫°p thu·∫≠t to√°n**

| Gi·∫£i ph√°p                             | Th·ªùi gian    | Kh√¥ng gian |
| ------------------------------------- | ------------ | ---------- |
| **HashMap**                           | `O(n)`       | `O(n)`     |
| **Hai con tr·ªè (Sort + Two Pointers)** | `O(n log n)` | `O(1)`     |

## **T√≥m t·∫Øt**

1. **D√πng HashMap (`O(n)`)** ƒë·ªÉ l∆∞u t·∫ßn su·∫•t s·ªë ƒë√£ duy·ªát, t√¨m `k - num`.
2. **D√πng Two Pointers (`O(n log n)`)** n·∫øu mu·ªën t·ªëi ∆∞u b·ªô nh·ªõ (`O(1)`).
3. **Kh√¥ng d√πng m·∫£ng ph·ª•, m·ªói ph·∫ßn t·ª≠ ch·ªâ x√©t m·ªôt l·∫ßn**.



