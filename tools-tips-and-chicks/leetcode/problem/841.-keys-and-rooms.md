# 841. Keys and Rooms

## Problem

[https://leetcode.com/problems/keys-and-rooms](https://leetcode.com/problems/keys-and-rooms)

***

## **ğŸ“ MÃ´ táº£:**

Báº¡n cÃ³ má»™t tÃ²a nhÃ  vá»›i **n** phÃ²ng Ä‘Æ°á»£c Ä‘Ã¡nh sá»‘ tá»« `0` Ä‘áº¿n `n-1`.\
Ban Ä‘áº§u, báº¡n Ä‘ang á»Ÿ **phÃ²ng 0**. Má»—i phÃ²ng cÃ³ thá»ƒ chá»©a má»™t sá»‘ chÃ¬a khÃ³a Ä‘á»ƒ má»Ÿ cÃ¡c phÃ²ng khÃ¡c.\
Má»™t danh sÃ¡ch `rooms[i]` chá»©a cÃ¡c **chÃ¬a khÃ³a** cÃ³ thá»ƒ má»Ÿ cÃ¡c phÃ²ng tÆ°Æ¡ng á»©ng.\
HÃ£y kiá»ƒm tra xem **báº¡n cÃ³ thá»ƒ má»Ÿ táº¥t cáº£ cÃ¡c phÃ²ng hay khÃ´ng**.

***

## **ğŸ’¡ VÃ­ dá»¥:**

#### âœ… **VÃ­ dá»¥ 1:**

**Input:**

```
rooms = [[1],[2],[3],[]]
```

**Output:**

```
true
```

**Giáº£i thÃ­ch:**

* PhÃ²ng `0` cÃ³ chÃ¬a khÃ³a phÃ²ng `1`.
* PhÃ²ng `1` cÃ³ chÃ¬a khÃ³a phÃ²ng `2`.
* PhÃ²ng `2` cÃ³ chÃ¬a khÃ³a phÃ²ng `3`.\
  â†’ **Táº¥t cáº£ cÃ¡c phÃ²ng cÃ³ thá»ƒ má»Ÿ Ä‘Æ°á»£c**.

***

#### âœ… **VÃ­ dá»¥ 2:**

**Input:**

```
rooms = [[1,3],[3,0,1],[2],[0]]
```

**Output:**

```
false
```

**Giáº£i thÃ­ch:**

* KhÃ´ng thá»ƒ má»Ÿ phÃ²ng `2` vÃ¬ khÃ´ng cÃ³ chÃ¬a khÃ³a nÃ o dáº«n Ä‘áº¿n phÃ²ng `2`.

***

## **ğŸš€ Giáº£i phÃ¡p**

BÃ i toÃ¡n nÃ y cÃ³ thá»ƒ Ä‘Æ°á»£c giáº£i quyáº¿t báº±ng **DFS hoáº·c BFS** Ä‘á»ƒ kiá»ƒm tra xem táº¥t cáº£ cÃ¡c phÃ²ng cÃ³ thá»ƒ Ä‘Æ°á»£c má»Ÿ khÃ´ng.

### **1ï¸âƒ£ Giáº£i phÃ¡p DFS**

* Sá»­ dá»¥ng **Stack** Ä‘á»ƒ duyá»‡t qua cÃ¡c phÃ²ng.
* Báº¯t Ä‘áº§u tá»« phÃ²ng `0`, láº§n lÆ°á»£t má»Ÿ cÃ¡c phÃ²ng báº±ng chÃ¬a khÃ³a cÃ³ Ä‘Æ°á»£c.
* Náº¿u cuá»‘i cÃ¹ng **táº¥t cáº£ cÃ¡c phÃ²ng** Ä‘á»u Ä‘Ã£ Ä‘Æ°á»£c má»Ÿ, tráº£ vá» `true`, ngÆ°á»£c láº¡i `false`.

***

### **ğŸ“œ Code**

{% tabs %}
{% tab title="C++" %}
```cpp
class Solution {
public:
    void dfs(vector<vector<int>>& rooms, vector<bool>& visited, int room) {
        visited[room] = true;
        for (int key : rooms[room]) {
            if (!visited[key]) dfs(rooms, visited, key);
        }
    }
    
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        int n = rooms.size();
        vector<bool> visited(n, false);
        dfs(rooms, visited, 0);
        return all_of(visited.begin(), visited.end(), [](bool v) { return v; });
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
class Solution {
    public void dfs(List<List<Integer>> rooms, boolean[] visited, int room) {
        visited[room] = true;
        for (int key : rooms.get(room)) {
            if (!visited[key]) dfs(rooms, visited, key);
        }
    }

    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();
        boolean[] visited = new boolean[n];
        dfs(rooms, visited, 0);
        
        for (boolean v : visited) {
            if (!v) return false;
        }
        return true;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        visited = set()
        
        def dfs(room):
            visited.add(room)
            for key in rooms[room]:
                if key not in visited:
                    dfs(key)

        dfs(0)
        return len(visited) == len(rooms)
```
{% endtab %}
{% endtabs %}

***

### **2ï¸âƒ£ Giáº£i phÃ¡p BFS**

* Sá»­ dá»¥ng **Queue** Ä‘á»ƒ duyá»‡t tá»«ng phÃ²ng.
* Báº¯t Ä‘áº§u tá»« phÃ²ng `0`, má»Ÿ tá»«ng phÃ²ng theo cÃ¡c chÃ¬a khÃ³a thu tháº­p Ä‘Æ°á»£c.
* Kiá»ƒm tra náº¿u **táº¥t cáº£ cÃ¡c phÃ²ng** Ä‘Æ°á»£c má»Ÿ, tráº£ vá» `true`, ngÆ°á»£c láº¡i `false`.

***

### ğŸ“œCode

{% tabs %}
{% tab title="C++" %}
```cpp
class Solution {
public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        int n = rooms.size();
        vector<bool> visited(n, false);
        queue<int> q;
        q.push(0);
        visited[0] = true;
        
        while (!q.empty()) {
            int room = q.front();
            q.pop();
            for (int key : rooms[room]) {
                if (!visited[key]) {
                    visited[key] = true;
                    q.push(key);
                }
            }
        }
        return all_of(visited.begin(), visited.end(), [](bool v) { return v; });
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
import java.util.*;

class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();
        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();
        
        queue.add(0);
        visited[0] = true;

        while (!queue.isEmpty()) {
            int room = queue.poll();
            for (int key : rooms.get(room)) {
                if (!visited[key]) {
                    visited[key] = true;
                    queue.add(key);
                }
            }
        }
        
        for (boolean v : visited) {
            if (!v) return false;
        }
        return true;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
from collections import deque

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        visited = set([0])
        queue = deque([0])
        
        while queue:
            room = queue.popleft()
            for key in rooms[room]:
                if key not in visited:
                    visited.add(key)
                    queue.append(key)
        
        return len(visited) == len(rooms)
```
{% endtab %}
{% endtabs %}

***

## **ğŸ¯ Äiá»ƒm chÃ­nh**

âœ” **DFS** vÃ  **BFS** Ä‘á»u cÃ³ thá»ƒ dÃ¹ng Ä‘á»ƒ kiá»ƒm tra táº¥t cáº£ phÃ²ng cÃ³ thá»ƒ má»Ÿ khÃ´ng.\
âœ” **DFS** dÃ¹ng **stack Ä‘á»‡ quy**, **BFS** dÃ¹ng **hÃ ng Ä‘á»£i** Ä‘á»ƒ duyá»‡t dáº§n tá»«ng phÃ²ng.\
âœ” DÃ¹ng **máº£ng `visited` hoáº·c táº­p há»£p `set`** Ä‘á»ƒ theo dÃµi cÃ¡c phÃ²ng Ä‘Ã£ má»Ÿ.

***

## **â³ Äá»™ phá»©c táº¡p thuáº­t toÃ¡n**

| PhÆ°Æ¡ng phÃ¡p     | Thá»i gian  | KhÃ´ng gian |
| --------------- | ---------- | ---------- |
| **DFS (Stack)** | `O(n + e)` | `O(n)`     |
| **BFS (Queue)** | `O(n + e)` | `O(n)`     |

* `n` lÃ  sá»‘ lÆ°á»£ng phÃ²ng.
* `e` lÃ  tá»•ng sá»‘ chÃ¬a khÃ³a trong danh sÃ¡ch `rooms`.

***

## **ğŸ“Œ Tá»•ng káº¿t**

* **BÃ i toÃ¡n yÃªu cáº§u kiá»ƒm tra xem cÃ³ thá»ƒ má»Ÿ táº¥t cáº£ phÃ²ng khÃ´ng.**
* **DÃ¹ng DFS hoáº·c BFS** Ä‘á»ƒ duyá»‡t tá»« phÃ²ng `0` Ä‘áº¿n cÃ¡c phÃ²ng cÃ³ thá»ƒ má»Ÿ.
* **DFS dÃ¹ng Ä‘á»‡ quy hoáº·c stack**, **BFS dÃ¹ng queue**.
* **Äá»™ phá»©c táº¡p `O(n + e)`, khÃ´ng gian `O(n)`.**
* âœ… **Giáº£i phÃ¡p hiá»‡u quáº£ cho Ä‘á»“ thá»‹ cÃ³ cáº¡nh Ã­t.**
