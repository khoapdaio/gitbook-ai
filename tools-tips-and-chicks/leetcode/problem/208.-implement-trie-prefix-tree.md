# 208. Implement Trie (Prefix Tree)

## **â“ Problem:**&#x20;

#### [**Leetcode: 208. Implement Trie (Prefix Tree)**](https://leetcode.com/problems/implement-trie-prefix-tree)

***

## **ğŸ“ MÃ´ táº£:**

Thiáº¿t káº¿ cáº¥u trÃºc dá»¯ liá»‡u **Trie** (hay cÃ²n gá»i lÃ  **Prefix Tree**) há»— trá»£ ba thao tÃ¡c:

1. `insert(String word)`: ChÃ¨n tá»« `word` vÃ o Trie.
2. `search(String word)`: Kiá»ƒm tra tá»« `word` cÃ³ tá»“n táº¡i trong Trie khÃ´ng.
3. `startsWith(String prefix)`: Kiá»ƒm tra cÃ³ tá»« nÃ o trong Trie báº¯t Ä‘áº§u báº±ng `prefix` khÃ´ng.

***

## **ğŸ’¡ VÃ­ dá»¥:**

#### **âœ… VÃ­ dá»¥ 1:**

ğŸ”¹ **Input:**

```plaintext
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
```

ğŸ”¹ **Output:**

```plaintext
[null, null, true, false, true, null, true]
```

ğŸ”¹ **Giáº£i thÃ­ch:**

```plaintext
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // Tráº£ vá» true
trie.search("app");     // Tráº£ vá» false
trie.startsWith("app"); // Tráº£ vá» true
trie.insert("app");
trie.search("app");     // Tráº£ vá» true
```

***

### **ğŸš€ Giáº£i phÃ¡p**

#### **Ã tÆ°á»Ÿng:**

* Trie lÃ  má»™t **cÃ¢y N-ary (cÃ¢y tiá»n tá»‘)**, trong Ä‘Ã³ má»—i nÃºt Ä‘áº¡i diá»‡n cho má»™t kÃ½ tá»± cá»§a tá»«.
* Má»—i **nÃºt** chá»©a:
  * **Má»™t máº£ng con trá»** Ä‘áº¿n cÃ¡c kÃ½ tá»± con (`children`).
  * **Cá» Ä‘Ã¡nh dáº¥u** náº¿u tá»« káº¿t thÃºc táº¡i nÃºt Ä‘Ã³ (`isEnd`).

***

## **ğŸ“œ Code**

{% tabs %}
{% tab title="C++" %}
```cpp
class Trie {
public:
    struct TrieNode {
        TrieNode* children[26] = {}; // 26 chá»¯ cÃ¡i tiáº¿ng Anh
        bool isEnd = false;
    };
    
    TrieNode* root;

    Trie() {
        root = new TrieNode();
    }

    void insert(string word) {
        TrieNode* node = root;
        for (char c : word) {
            if (!node->children[c - 'a'])
                node->children[c - 'a'] = new TrieNode();
            node = node->children[c - 'a'];
        }
        node->isEnd = true;
    }

    bool search(string word) {
        TrieNode* node = root;
        for (char c : word) {
            if (!node->children[c - 'a'])
                return false;
            node = node->children[c - 'a'];
        }
        return node->isEnd;
    }

    bool startsWith(string prefix) {
        TrieNode* node = root;
        for (char c : prefix) {
            if (!node->children[c - 'a'])
                return false;
            node = node->children[c - 'a'];
        }
        return true;
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
class Trie {
    class TrieNode {
        TrieNode[] children = new TrieNode[26];
        boolean isEnd = false;
    }
    
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            if (node.children[c - 'a'] == null)
                node.children[c - 'a'] = new TrieNode();
            node = node.children[c - 'a'];
        }
        node.isEnd = true;
    }
    
    public boolean search(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            if (node.children[c - 'a'] == null)
                return false;
            node = node.children[c - 'a'];
        }
        return node.isEnd;
    }
    
    public boolean startsWith(String prefix) {
        TrieNode node = root;
        for (char c : prefix.toCharArray()) {
            if (node.children[c - 'a'] == null)
                return false;
            node = node.children[c - 'a'];
        }
        return true;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.isEnd = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word: str) -> None:
        node = self.root
        for c in word:
            if c not in node.children:
                node.children[c] = TrieNode()
            node = node.children[c]
        node.isEnd = True
    
    def search(self, word: str) -> bool:
        node = self.root
        for c in word:
            if c not in node.children:
                return False
            node = node.children[c]
        return node.isEnd
    
    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for c in prefix:
            if c not in node.children:
                return False
            node = node.children[c]
        return True
```
{% endtab %}
{% endtabs %}

***

## **ğŸ¯ Äiá»ƒm chÃ­nh**

âœ… **Trie (Prefix Tree) hoáº¡t Ä‘á»™ng nhÆ° má»™t cÃ¢y tÃ¬m kiáº¿m tiá»n tá»‘:**

* **Má»—i nÃºt** chá»©a 26 con trá» (vá»›i chá»¯ cÃ¡i tá»« `a` Ä‘áº¿n `z`).
* **`insert()`**: Láº§n lÆ°á»£t chÃ¨n tá»«ng kÃ½ tá»± vÃ o Trie.
* **`search()`**: Kiá»ƒm tra tá»« cÃ³ tá»“n táº¡i khÃ´ng.
* **`startsWith()`**: Kiá»ƒm tra tiá»n tá»‘ cÃ³ tá»“n táº¡i khÃ´ng.

***

## **â³ Äá»™ phá»©c táº¡p thuáº­t toÃ¡n**

* **Thá»i gian:**
  * `insert()`, `search()`, `startsWith()` â†’ `O(N)`, vá»›i `N` lÃ  Ä‘á»™ dÃ i cá»§a tá»«.
* **KhÃ´ng gian:**
  * `O(N * M)`, vá»›i `N` lÃ  sá»‘ tá»«, `M` lÃ  Ä‘á»™ dÃ i trung bÃ¬nh cá»§a tá»«.

***

## **ğŸ“Œ Tá»•ng káº¿t**

ğŸš€ **Trie giÃºp tÃ¬m kiáº¿m tá»« hoáº·c tiá»n tá»‘ nhanh chÃ³ng vá»›i Ä‘á»™ phá»©c táº¡p O(N).**\
âœ… **Dá»¯ liá»‡u Ä‘Æ°á»£c lÆ°u trá»¯ trong cáº¥u trÃºc cÃ¢y thay vÃ¬ sá»­ dá»¥ng hash map hoáº·c máº£ng thÃ´ng thÆ°á»ng.**\
ğŸ”¥ **á»¨ng dá»¥ng trong há»‡ thá»‘ng gá»£i Ã½ tá»«, kiá»ƒm tra chÃ­nh táº£, vÃ  tÃ¬m kiáº¿m tá»« tá»± Ä‘á»™ng.**
