# 547. Number of Provinces

## Problem

[https://leetcode.com/problems/number-of-provinces](https://leetcode.com/problems/number-of-provinces)

***

## **ğŸ“ MÃ´ táº£:**

Má»™t tá»‰nh Ä‘Æ°á»£c Ä‘á»‹nh nghÄ©a lÃ  má»™t nhÃ³m cÃ¡c thÃ nh phá»‘ trá»±c tiáº¿p hoáº·c giÃ¡n tiáº¿p Ä‘Æ°á»£c káº¿t ná»‘i vá»›i nhau báº±ng má»™t tuyáº¿n Ä‘Æ°á»ng vÃ  khÃ´ng cÃ³ thÃ nh phá»‘ nÃ o bÃªn ngoÃ i nhÃ³m.\
Báº¡n Ä‘Æ°á»£c cung cáº¥p má»™t **ma tráº­n ká» `isConnected`**, trong Ä‘Ã³ `isConnected[i][j] = 1` náº¿u thÃ nh phá»‘ `i` vÃ  `j` Ä‘Æ°á»£c káº¿t ná»‘i trá»±c tiáº¿p, `0` náº¿u khÃ´ng.

HÃ£y tráº£ vá» **sá»‘ lÆ°á»£ng tá»‰nh** cÃ³ thá»ƒ tÃ¬m tháº¥y trong ma tráº­n.

***

## **ğŸ’¡ VÃ­ dá»¥:**

#### âœ… **VÃ­ dá»¥ 1:**

**Input:**

```
isConnected = [[1,1,0],
               [1,1,0],
               [0,0,1]]
```

**Output:**

```
2
```

**Giáº£i thÃ­ch:**

* ThÃ nh phá»‘ `0` vÃ  `1` Ä‘Æ°á»£c káº¿t ná»‘i vá»›i nhau táº¡o thÃ nh má»™t **tá»‰nh**.
* ThÃ nh phá»‘ `2` khÃ´ng Ä‘Æ°á»£c káº¿t ná»‘i vá»›i báº¥t ká»³ ai, táº¡o thÃ nh má»™t **tá»‰nh** riÃªng biá»‡t.

***

#### âœ… **VÃ­ dá»¥ 2:**

**Input:**

```
isConnected = [[1,0,0],
               [0,1,0],
               [0,0,1]]
```

**Output:**

```
3
```

**Giáº£i thÃ­ch:**

* Má»—i thÃ nh phá»‘ tá»± táº¡o thÃ nh má»™t **tá»‰nh** riÃªng biá»‡t.

***

## **ğŸš€ Giáº£i phÃ¡p**

BÃ i toÃ¡n nÃ y cÃ³ thá»ƒ Ä‘Æ°á»£c giáº£i quyáº¿t báº±ng **DFS hoáº·c BFS** Ä‘á»ƒ tÃ¬m cÃ¡c thÃ nh phá»‘ liÃªn thÃ´ng (tá»©c lÃ  tÃ¬m **thÃ nh pháº§n liÃªn thÃ´ng** trong Ä‘á»“ thá»‹).

### **1ï¸âƒ£ Giáº£i phÃ¡p DFS**

* Duyá»‡t qua tá»«ng thÃ nh phá»‘, náº¿u chÆ°a Ä‘Æ°á»£c thÄƒm thÃ¬ **tÄƒng sá»‘ lÆ°á»£ng tá»‰nh lÃªn 1**.
* Tá»« thÃ nh phá»‘ Ä‘Ã³, dÃ¹ng DFS Ä‘á»ƒ Ä‘Ã¡nh dáº¥u táº¥t cáº£ thÃ nh phá»‘ káº¿t ná»‘i vá»›i nÃ³.
* Tiáº¿p tá»¥c duyá»‡t qua danh sÃ¡ch thÃ nh phá»‘ Ä‘á»ƒ tÃ¬m cÃ¡c cá»¥m liÃªn thÃ´ng.

***

### **ğŸ“œ Code**

{% tabs %}
{% tab title="C++" %}
```cpp
class Solution {
public:
    void dfs(vector<vector<int>>& isConnected, vector<bool>& visited, int city) {
        visited[city] = true;
        for (int i = 0; i < isConnected.size(); i++) {
            if (isConnected[city][i] == 1 && !visited[i]) {
                dfs(isConnected, visited, i);
            }
        }
    }

    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        vector<bool> visited(n, false);
        int provinces = 0;
        
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(isConnected, visited, i);
                provinces++;
            }
        }
        return provinces;
    }
};
```


{% endtab %}

{% tab title="Java" %}
```java
class Solution {
    public void dfs(int[][] isConnected, boolean[] visited, int city) {
        visited[city] = true;
        for (int i = 0; i < isConnected.length; i++) {
            if (isConnected[city][i] == 1 && !visited[i]) {
                dfs(isConnected, visited, i);
            }
        }
    }

    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        boolean[] visited = new boolean[n];
        int provinces = 0;
        
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(isConnected, visited, i);
                provinces++;
            }
        }
        return provinces;
    }
}
```


{% endtab %}

{% tab title="Python" %}
```python
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def dfs(city):
            visited.add(city)
            for neighbor, connected in enumerate(isConnected[city]):
                if connected and neighbor not in visited:
                    dfs(neighbor)
        
        visited = set()
        provinces = 0

        for i in range(len(isConnected)):
            if i not in visited:
                dfs(i)
                provinces += 1
                
        return provinces
```


{% endtab %}
{% endtabs %}

***

### **2ï¸âƒ£ Giáº£i phÃ¡p BFS**

* DÃ¹ng **Queue** Ä‘á»ƒ duyá»‡t táº¥t cáº£ thÃ nh phá»‘ liÃªn thÃ´ng báº¯t Ä‘áº§u tá»« má»™t thÃ nh phá»‘ chÆ°a Ä‘Æ°á»£c thÄƒm.
* Náº¿u gáº·p má»™t thÃ nh phá»‘ chÆ°a Ä‘Æ°á»£c Ä‘Ã¡nh dáº¥u, ta thÃªm nÃ³ vÃ o hÃ ng Ä‘á»£i vÃ  tiáº¿p tá»¥c má»Ÿ rá»™ng.
* **Láº·p qua táº¥t cáº£ cÃ¡c thÃ nh phá»‘**, Ä‘áº¿m sá»‘ láº§n báº¯t Ä‘áº§u BFS Ä‘á»ƒ xÃ¡c Ä‘á»‹nh sá»‘ tá»‰nh.

***

### **ğŸ“œ Code**

{% tabs %}
{% tab title="C++" %}
```cpp
class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        vector<bool> visited(n, false);
        int provinces = 0;
        queue<int> q;

        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                q.push(i);
                while (!q.empty()) {
                    int city = q.front();
                    q.pop();
                    visited[city] = true;
                    for (int j = 0; j < n; j++) {
                        if (isConnected[city][j] == 1 && !visited[j]) {
                            q.push(j);
                        }
                    }
                }
                provinces++;
            }
        }
        return provinces;
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
import java.util.*;

class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        boolean[] visited = new boolean[n];
        int provinces = 0;
        Queue<Integer> queue = new LinkedList<>();

        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                queue.add(i);
                while (!queue.isEmpty()) {
                    int city = queue.poll();
                    visited[city] = true;
                    for (int j = 0; j < n; j++) {
                        if (isConnected[city][j] == 1 && !visited[j]) {
                            queue.add(j);
                        }
                    }
                }
                provinces++;
            }
        }
        return provinces;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
from collections import deque

class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        visited = set()
        provinces = 0

        for i in range(len(isConnected)):
            if i not in visited:
                queue = deque([i])
                while queue:
                    city = queue.popleft()
                    visited.add(city)
                    for neighbor, connected in enumerate(isConnected[city]):
                        if connected and neighbor not in visited:
                            queue.append(neighbor)
                provinces += 1
        
        return provinces
```
{% endtab %}
{% endtabs %}

***

## **ğŸ¯ Äiá»ƒm chÃ­nh**

âœ” **DFS vÃ  BFS** Ä‘á»u lÃ  cÃ¡ch hiá»‡u quáº£ Ä‘á»ƒ tÃ¬m thÃ nh pháº§n liÃªn thÃ´ng trong Ä‘á»“ thá»‹.\
âœ” **DFS sá»­ dá»¥ng Ä‘á»‡ quy**, **BFS sá»­ dá»¥ng hÃ ng Ä‘á»£i**.\
âœ” **Sá»­ dá»¥ng `visited[]` Ä‘á»ƒ trÃ¡nh láº·p láº¡i cÃ¡c thÃ nh phá»‘ Ä‘Ã£ kiá»ƒm tra.**

***

## **â³ Äá»™ phá»©c táº¡p thuáº­t toÃ¡n**

| PhÆ°Æ¡ng phÃ¡p     | Thá»i gian | KhÃ´ng gian |
| --------------- | --------- | ---------- |
| **DFS (Stack)** | `O(n^2)`  | `O(n)`     |
| **BFS (Queue)** | `O(n^2)`  | `O(n)`     |

`=> n` lÃ  sá»‘ thÃ nh phá»‘, `O(n^2)` do duyá»‡t ma tráº­n `isConnected`.

***

## **ğŸ“Œ Tá»•ng káº¿t**

* **BÃ i toÃ¡n yÃªu cáº§u tÃ¬m sá»‘ tá»‰nh, tá»©c lÃ  sá»‘ thÃ nh pháº§n liÃªn thÃ´ng cá»§a Ä‘á»“ thá»‹.**
* **DFS vÃ  BFS Ä‘á»u cÃ³ thá»ƒ giáº£i quyáº¿t hiá»‡u quáº£ bÃ i toÃ¡n nÃ y.**
* **DFS sá»­ dá»¥ng stack Ä‘á»‡ quy, BFS dÃ¹ng queue Ä‘á»ƒ duyá»‡t.**
* **Thá»i gian `O(n^2)`, khÃ´ng gian `O(n)`.**
* âœ… **á»¨ng dá»¥ng: tÃ¬m nhÃ³m ngÆ°á»i báº¡n, cá»¥m máº¡ng lÆ°á»›i trong há»‡ thá»‘ng, v.v.**
