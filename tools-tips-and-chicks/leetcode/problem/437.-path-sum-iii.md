# 437. Path Sum III

## ğŸ”—Problem

[https://leetcode.com/problems/path-sum-iii](https://leetcode.com/problems/path-sum-iii)

## **ğŸ“Œ MÃ´ táº£ bÃ i toÃ¡n**

Cho cÃ¢y nhá»‹ phÃ¢n `root` vÃ  má»™t sá»‘ nguyÃªn `targetSum`, hÃ£y **Ä‘áº¿m sá»‘ Ä‘Æ°á»ng Ä‘i** (path) **cÃ³ tá»•ng báº±ng targetSum**.

* **Má»™t Ä‘Æ°á»ng Ä‘i cÃ³ thá»ƒ báº¯t Ä‘áº§u tá»« báº¥t ká»³ node nÃ o vÃ  káº¿t thÃºc á»Ÿ báº¥t ká»³ node nÃ o** (khÃ´ng nháº¥t thiáº¿t pháº£i báº¯t Ä‘áº§u tá»« gá»‘c hoáº·c káº¿t thÃºc á»Ÿ lÃ¡).
* **ÄÆ°á»ng Ä‘i pháº£i Ä‘i xuá»‘ng** (tá»©c lÃ  chá»‰ cÃ³ thá»ƒ Ä‘i tá»« cha Ä‘áº¿n con, khÃ´ng Ä‘i ngÆ°á»£c lÃªn).

ğŸ“Œ **RÃ ng buá»™c:**

* `1 <= Number of nodes <= 10^4`
* `-1000 <= Node.val <= 1000`
* `-10^7 <= targetSum <= 10^7`

***

## **ğŸ’¡ VÃ­ dá»¥**

#### âœ… **VÃ­ dá»¥ 1**

```
Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
Output: 3
```

**Giáº£i thÃ­ch:**\
CÃ¢y nhá»‹ phÃ¢n:

```
        10
       /  \
      5   -3
     / \    \
    3   2    11
   / \   \
  3  -2   1
```

Ba Ä‘Æ°á»ng Ä‘i cÃ³ tá»•ng `8`:

1. `5 -> 3`
2. `5 -> 2 -> 1`
3. `-3 -> 11`

âœ… **Tá»•ng sá»‘ Ä‘Æ°á»ng Ä‘i = 3**

***

#### âœ… **VÃ­ dá»¥ 2**

```
textSao chÃ©pChá»‰nh sá»­aInput: root = [1], targetSum = 1
Output: 1
```

ğŸ“Œ **CÃ³ má»™t Ä‘Æ°á»ng Ä‘i duy nháº¥t:** `[1]`

âœ… **Káº¿t quáº£:** `1`

***

## **ğŸš€ Giáº£i phÃ¡p 1: DFS Brute Force (O(nÂ²))**

#### ğŸ“Œ **Ã tÆ°á»Ÿng chÃ­nh:**

1. Vá»›i má»—i node, thá»±c hiá»‡n **DFS** Ä‘á»ƒ tÃ¬m táº¥t cáº£ cÃ¡c Ä‘Æ°á»ng Ä‘i báº¯t Ä‘áº§u tá»« node Ä‘Ã³ cÃ³ tá»•ng `targetSum`.
2. Duyá»‡t qua táº¥t cáº£ cÃ¡c node Ä‘á»ƒ gá»i DFS.
3. **Thá»i gian:** `O(nÂ²)` trong trÆ°á»ng há»£p cÃ¢y cÃ¢n báº±ng.

***

#### âœ… **Java - DFS Brute Force**

```java
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        if (root == null) return 0;
        return dfs(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);
    }
    
    private int dfs(TreeNode node, long target) {
        if (node == null) return 0;
        int count = (node.val == target) ? 1 : 0;
        count += dfs(node.left, target - node.val);
        count += dfs(node.right, target - node.val);
        return count;
    }
}
```

**â³ Äá»™ phá»©c táº¡p:**

* Má»—i node Ä‘Æ°á»£c duyá»‡t má»™t láº§n Ä‘á»ƒ gá»i `dfs` â†’ `O(n)`.
* `dfs` duyá»‡t láº¡i `O(n)` node con â†’ `O(nÂ²)` tá»•ng thá»ƒ.\
  ğŸš« **KhÃ´ng tá»‘i Æ°u cho cÃ¢y lá»›n (`n = 10^4`)**

***

## **ğŸš€ Giáº£i phÃ¡p 2: Prefix Sum + HashMap (O(n))**

#### ğŸ“Œ **Ã tÆ°á»Ÿng chÃ­nh:**

* DÃ¹ng **Prefix Sum** Ä‘á»ƒ lÆ°u tá»•ng tá»« gá»‘c Ä‘áº¿n má»—i node.
* DÃ¹ng **HashMap** Ä‘á»ƒ Ä‘áº¿m sá»‘ láº§n xuáº¥t hiá»‡n cá»§a tá»«ng giÃ¡ trá»‹ `prefixSum`.
* Khi duyá»‡t DFS Ä‘áº¿n node `cur`, kiá»ƒm tra `prefixSum - targetSum` cÃ³ tá»“n táº¡i trong HashMap khÃ´ng.

ğŸ”¹ **Tá»‘i Æ°u tá»« `O(nÂ²)` xuá»‘ng `O(n)`.**

***

## ğŸ“œ Code

{% tabs %}
{% tab title="C++" %}
```cpp
#include <unordered_map>

class Solution {
public:
    int pathSum(TreeNode* root, int targetSum) {
        unordered_map<long, int> prefixMap;
        prefixMap[0] = 1;
        return dfs(root, 0, targetSum, prefixMap);
    }

    int dfs(TreeNode* node, long curSum, int target, unordered_map<long, int>& prefixMap) {
        if (!node) return 0;
        
        curSum += node->val;
        int count = prefixMap[curSum - target];
        
        prefixMap[curSum]++;
        
        count += dfs(node->left, curSum, target, prefixMap);
        count += dfs(node->right, curSum, target, prefixMap);
        
        prefixMap[curSum]--; // Backtrack
        
        return count;
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
import java.util.*;

class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        Map<Long, Integer> prefixMap = new HashMap<>();
        prefixMap.put(0L, 1);
        return dfs(root, 0L, targetSum, prefixMap);
    }
    
    private int dfs(TreeNode node, long curSum, int target, Map<Long, Integer> prefixMap) {
        if (node == null) return 0;
        
        curSum += node.val;
        int count = prefixMap.getOrDefault(curSum - target, 0);
        
        prefixMap.put(curSum, prefixMap.getOrDefault(curSum, 0) + 1);
        
        count += dfs(node.left, curSum, target, prefixMap);
        count += dfs(node.right, curSum, target, prefixMap);
        
        prefixMap.put(curSum, prefixMap.get(curSum) - 1); // Backtrack
        
        return count;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
from collections import defaultdict

class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        prefix_map = defaultdict(int)
        prefix_map[0] = 1
        return self.dfs(root, 0, targetSum, prefix_map)
    
    def dfs(self, node, cur_sum, target, prefix_map):
        if not node:
            return 0
        
        cur_sum += node.val
        count = prefix_map[cur_sum - target]
        
        prefix_map[cur_sum] += 1
        count += self.dfs(node.left, cur_sum, target, prefix_map)
        count += self.dfs(node.right, cur_sum, target, prefix_map)
        prefix_map[cur_sum] -= 1  # Backtrack
        
        return count
```
{% endtab %}
{% endtabs %}

***

### **â³ Äá»™ phá»©c táº¡p thuáº­t toÃ¡n**

| PhÆ°Æ¡ng phÃ¡p              | Thá»i gian | KhÃ´ng gian |
| ------------------------ | --------- | ---------- |
| **DFS Brute Force**      | `O(nÂ²)`   | `O(h)`     |
| **Prefix Sum + HashMap** | `O(n)`    | `O(n)`     |

âœ… **HashMap giÃºp giáº£m Ä‘á»™ phá»©c táº¡p tá»« `O(nÂ²)` xuá»‘ng `O(n)`.**\
âœ… **DÃ¹ng backtrack Ä‘á»ƒ trÃ¡nh áº£nh hÆ°á»Ÿng Ä‘áº¿n cÃ¡c Ä‘Æ°á»ng Ä‘i khÃ¡c.**

***

## **ğŸ“Œ Tá»•ng káº¿t**

âœ” **Duyá»‡t cÃ¢y DFS Ä‘á»ƒ kiá»ƒm tra tá»•ng Ä‘Æ°á»ng Ä‘i.**\
âœ” **DÃ¹ng Prefix Sum + HashMap Ä‘á»ƒ giáº£m Ä‘á»™ phá»©c táº¡p xuá»‘ng `O(n)`.**\
âœ” **á»¨ng dá»¥ng:** TÃ¬m sá»‘ Ä‘Æ°á»ng Ä‘i thá»a mÃ£n Ä‘iá»u kiá»‡n trÃªn cÃ¢y nhá»‹ phÃ¢n.
