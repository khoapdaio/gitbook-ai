# 1268. Search Suggestions System

## **‚ùì Problem:**&#x20;

[**Leetcode: 1268. Search Suggestions System**](https://leetcode.com/problems/search-suggestions-system)

***

## **üìù M√¥ t·∫£:**

Cho m·ªôt danh s√°ch `products` g·ªìm c√°c s·∫£n ph·∫©m (chu·ªói k√Ω t·ª±) ƒë∆∞·ª£c s·∫Øp x·∫øp kh√¥ng theo th·ª© t·ª± v√† m·ªôt chu·ªói `searchWord`.

* Khi nh·∫≠p t·ª´ng k√Ω t·ª± c·ªßa `searchWord`, hi·ªÉn th·ªã t·ªëi ƒëa **3 s·∫£n ph·∫©m** c√≥ ti·ªÅn t·ªë tr√πng v·ªõi chu·ªói nh·∫≠p v√†o **ƒë∆∞·ª£c s·∫Øp x·∫øp theo th·ª© t·ª± t·ª´ ƒëi·ªÉn**.
* N·∫øu kh√¥ng c√≥ s·∫£n ph·∫©m n√†o kh·ªõp, tr·∫£ v·ªÅ danh s√°ch r·ªóng cho l·∫ßn nh·∫≠p ƒë√≥.

***

## **üí° V√≠ d·ª•:**

#### **‚úÖ V√≠ d·ª• 1:**

üîπ **Input:**

```plaintext
products = ["mobile","mouse","moneypot","monitor","mousepad"]
searchWord = "mouse"
```

üîπ **Output:**

```plaintext
[
  ["mobile","moneypot","monitor"], 
  ["mobile","moneypot","monitor"], 
  ["mouse","mousepad"], 
  ["mouse","mousepad"], 
  ["mouse","mousepad"]
]
```

üîπ **Gi·∫£i th√≠ch:**

* Khi nh·∫≠p `"m"`, g·ª£i √Ω: `["mobile","moneypot","monitor"]`.
* Khi nh·∫≠p `"mo"`, g·ª£i √Ω: `["mobile","moneypot","monitor"]`.
* Khi nh·∫≠p `"mou"`, g·ª£i √Ω: `["mouse","mousepad"]`.
* Khi nh·∫≠p `"mous"`, g·ª£i √Ω: `["mouse","mousepad"]`.
* Khi nh·∫≠p `"mouse"`, g·ª£i √Ω: `["mouse","mousepad"]`.

***

## **üöÄ Gi·∫£i ph√°p 1: S·∫Øp x·∫øp + T√¨m ki·∫øm nh·ªã ph√¢n** (Optimal)

#### **√ù t∆∞·ªüng:**

1. S·∫Øp x·∫øp `products` theo th·ª© t·ª± t·ª´ ƒëi·ªÉn.
2. Khi nh·∫≠p t·ª´ng k√Ω t·ª± `searchWord[0:i]`, t√¨m v·ªã tr√≠ **ƒë·∫ßu ti√™n** xu·∫•t hi·ªán c·ªßa chu·ªói con b·∫±ng **Binary Search**.
3. L·∫•y t·ªëi ƒëa 3 ph·∫ßn t·ª≠ ph√π h·ª£p v√† th√™m v√†o danh s√°ch k·∫øt qu·∫£.

***

### **üìú Code**

{% tabs %}
{% tab title="C++" %}
```cpp
class Solution {
public:
    vector<vector<string>> suggestedProducts(vector<string>& products, string searchWord) {
        sort(products.begin(), products.end());
        vector<vector<string>> result;
        string prefix;
        auto it = products.begin();

        for (char c : searchWord) {
            prefix += c;
            it = lower_bound(it, products.end(), prefix);
            vector<string> suggestions;
            for (int i = 0; i < 3 && it + i != products.end(); ++i) {
                if ((it + i)->find(prefix) != 0) break;
                suggestions.push_back(*(it + i));
            }
            result.push_back(suggestions);
        }
        return result;
    }
};
```


{% endtab %}

{% tab title="Java" %}
```java
class Solution {
    public List<List<String>> suggestedProducts(String[] products, String searchWord) {
        Arrays.sort(products);
        List<List<String>> result = new ArrayList<>();
        String prefix = "";
        int start = 0;

        for (char c : searchWord.toCharArray()) {
            prefix += c;
            start = Arrays.binarySearch(products, start, products.length, prefix);
            if (start < 0) start = -start - 1;

            List<String> suggestions = new ArrayList<>();
            for (int i = start; i < Math.min(start + 3, products.length); i++) {
                if (!products[i].startsWith(prefix)) break;
                suggestions.add(products[i]);
            }
            result.add(suggestions);
        }
        return result;
    }
}
```


{% endtab %}

{% tab title="Python" %}
```python
from bisect import bisect_left

class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        products.sort()
        result, prefix = [], ""
        index = 0
        
        for char in searchWord:
            prefix += char
            index = bisect_left(products, prefix, index)
            result.append([p for p in products[index:index+3] if p.startswith(prefix)])
        
        return result
```
{% endtab %}
{% endtabs %}

***

## **üöÄ Gi·∫£i ph√°p 2: Trie (Prefix Tree)**

#### **√ù t∆∞·ªüng:**

* **B∆∞·ªõc 1:** D√πng Trie ƒë·ªÉ l∆∞u danh s√°ch t·ª´ `products`.
* **B∆∞·ªõc 2:** Khi nh·∫≠p t·ª´ng k√Ω t·ª± `searchWord[0:i]`, t√¨m ƒë·∫øn n√∫t cu·ªëi c√πng c·ªßa ti·ªÅn t·ªë ƒë√≥ trong Trie.
* **B∆∞·ªõc 3:** Duy·ªát c√°c con ƒë·ªÉ l·∫•y t·ªëi ƒëa 3 g·ª£i √Ω.

***

### **üìú Code**

{% tabs %}
{% tab title="C++" %}
```cpp
class TrieNode {
public:
    TrieNode* children[26] = {};
    vector<string> words;
};

class Trie {
public:
    TrieNode* root;
    
    Trie() { root = new TrieNode(); }
    
    void insert(string word) {
        TrieNode* node = root;
        for (char c : word) {
            if (!node->children[c - 'a'])
                node->children[c - 'a'] = new TrieNode();
            node = node->children[c - 'a'];
            if (node->words.size() < 3)
                node->words.push_back(word);
        }
    }
    
    vector<string> search(string prefix) {
        TrieNode* node = root;
        for (char c : prefix) {
            if (!node->children[c - 'a']) return {};
            node = node->children[c - 'a'];
        }
        return node->words;
    }
};

class Solution {
public:
    vector<vector<string>> suggestedProducts(vector<string>& products, string searchWord) {
        Trie trie;
        sort(products.begin(), products.end());
        for (const string& product : products)
            trie.insert(product);
        
        vector<vector<string>> result;
        string prefix;
        for (char c : searchWord) {
            prefix += c;
            result.push_back(trie.search(prefix));
        }
        return result;
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
class TrieNode {
    Map<Character, TrieNode> children = new HashMap<>();
    List<String> words = new ArrayList<>();
}

class Trie {
    TrieNode root;
    
    Trie() { root = new TrieNode(); }
    
    void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            node.children.putIfAbsent(c, new TrieNode());
            node = node.children.get(c);
            if (node.words.size() < 3)
                node.words.add(word);
        }
    }
    
    List<String> search(String prefix) {
        TrieNode node = root;
        for (char c : prefix.toCharArray()) {
            if (!node.children.containsKey(c)) return new ArrayList<>();
            node = node.children.get(c);
        }
        return node.words;
    }
}

class Solution {
    public List<List<String>> suggestedProducts(String[] products, String searchWord) {
        Trie trie = new Trie();
        Arrays.sort(products);
        for (String product : products)
            trie.insert(product);
        
        List<List<String>> result = new ArrayList<>();
        String prefix = "";
        for (char c : searchWord.toCharArray()) {
            prefix += c;
            result.add(trie.search(prefix));
        }
        return result;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.words = []

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for c in word:
            if c not in node.children:
                node.children[c] = TrieNode()
            node = node.children[c]
            if len(node.words) < 3:
                node.words.append(word)

    def search(self, prefix):
        node = self.root
        for c in prefix:
            if c not in node.children:
                return []
            node = node.children[c]
        return node.words

class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        trie = Trie()
        for product in sorted(products):
            trie.insert(product)

        prefix = ""
        result = []
        for c in searchWord:
            prefix += c
            result.append(trie.search(prefix))
        return result
```
{% endtab %}
{% endtabs %}

***

### **üéØ ƒêi·ªÉm ch√≠nh**

‚úÖ **Binary Search nhanh h∆°n nh∆∞ng kh√≥ m·ªü r·ªông.**\
‚úÖ **Trie gi√∫p t√¨m ki·∫øm ti·ªÅn t·ªë hi·ªáu qu·∫£ v√† c√≥ th·ªÉ m·ªü r·ªông th√™m t√≠nh nƒÉng.**

***

### **‚è≥ ƒê·ªô ph·ª©c t·∫°p thu·∫≠t to√°n**

| Ph∆∞∆°ng ph√°p       | Th·ªùi gian              | Kh√¥ng gian |
| ----------------- | ---------------------- | ---------- |
| **Binary Search** | `O(N log N + M log N)` | `O(N)`     |
| **Trie**          | `O(N log N + M)`       | `O(N * M)` |

***

### **üìå T·ªïng k·∫øt**

üöÄ **S·ª≠ d·ª•ng Trie n·∫øu c·∫ßn m·ªü r·ªông th√™m t√≠nh nƒÉng.**\
üî• **Binary Search ƒë∆°n gi·∫£n h∆°n v√† ph√π h·ª£p v·ªõi b√†i to√°n hi·ªán t·∫°i.**
