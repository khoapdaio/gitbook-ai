# 875. Koko Eating Bananas

## **â“ Problem:**

ğŸ”— [LeetCode 875 - Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas)

***

## **ğŸ“ MÃ´ táº£:**

Koko thÃ­ch Äƒn chuá»‘i. CÃ³ `n` chá»“ng chuá»‘i, `piles[i]` lÃ  sá»‘ lÆ°á»£ng chuá»‘i trong chá»“ng thá»© `i`. Koko cÃ³ `h` giá» Ä‘á»ƒ Äƒn háº¿t táº¥t cáº£ chuá»‘i.

Má»—i giá», Koko cÃ³ thá»ƒ Äƒn **tá»‘i Ä‘a `k` quáº£ chuá»‘i** tá»« **má»™t chá»“ng**. Náº¿u cÃ²n dÆ°, chá»“ng Ä‘Ã³ váº«n giá»¯ nguyÃªn sá»‘ chuá»‘i cÃ²n láº¡i.

HÃ£y tÃ¬m **tá»‘c Ä‘á»™ Äƒn chuá»‘i `k` nhá» nháº¥t** Ä‘á»ƒ Koko Äƒn háº¿t táº¥t cáº£ chuá»‘i trong `h` giá».

***

## **ğŸ’¡ VÃ­ dá»¥:**

#### âœ… **VÃ­ dá»¥ 1:**

**Input:**

```cpp
piles = [3,6,7,11], h = 8
```

**Output:**

```cpp
4
```

**Giáº£i thÃ­ch:**

* Náº¿u Äƒn vá»›i `k = 4`, Koko cÃ³ thá»ƒ hoÃ n thÃ nh trong 8 giá».

***

#### âœ… **VÃ­ dá»¥ 2:**

**Input:**

```cpp
piles = [30,11,23,4,20], h = 5
```

**Output:**

```cpp
30
```

**Giáº£i thÃ­ch:**

* Náº¿u Äƒn vá»›i `k = 30`, Koko cÃ³ thá»ƒ Äƒn xong trong 5 giá».

***

## **ğŸš€ Giáº£i phÃ¡p**

BÃ i toÃ¡n yÃªu cáº§u tÃ¬m **tá»‘c Ä‘á»™ tá»‘i thiá»ƒu** sao cho Koko cÃ³ thá»ƒ Äƒn háº¿t trong `h` giá».

#### **1ï¸âƒ£ Duyá»‡t tuyáº¿n tÃ­nh (`O(max(piles) * n)`)**

* Thá»­ tá»«ng tá»‘c Ä‘á»™ `k` tá»« `1` Ä‘áº¿n `max(piles)`.
* Vá»›i má»—i `k`, kiá»ƒm tra náº¿u Äƒn háº¿t trong `h` giá».
* **NhÆ°á»£c Ä‘iá»ƒm:** Ráº¥t cháº­m náº¿u `max(piles)` lá»›n.

#### **2ï¸âƒ£ Binary Search (`O(n log max(piles))`)**

* **GiÃ¡ trá»‹ nhá» nháº¥t** cá»§a `k` lÃ  `1`, **giÃ¡ trá»‹ lá»›n nháº¥t** lÃ  `max(piles)`.
* DÃ¹ng **Binary Search** Ä‘á»ƒ tÃ¬m tá»‘c Ä‘á»™ nhá» nháº¥t `k` sao cho Äƒn háº¿t trong `h` giá».
* **Kiá»ƒm tra sá»‘ giá» cáº§n thiáº¿t vá»›i má»—i `k`** báº±ng cÃ¡ch tÃ­nh tá»•ng `ceil(piles[i] / k)`.

***

## **ğŸ“œ Code - Binary Search**

{% tabs %}
{% tab title="C++" %}
```cpp
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        int left = 1, right = *max_element(piles.begin(), piles.end());
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            int hours = 0;
            
            for (int p : piles) {
                hours += (p + mid - 1) / mid; // TÃ­nh ceil(p / mid)
            }
            
            if (hours > h) left = mid + 1; // Cáº§n tÄƒng tá»‘c Ä‘á»™
            else right = mid; // Giá»¯ tá»‘c Ä‘á»™ nhá» hÆ¡n
        }
        return left;
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int left = 1, right = Arrays.stream(piles).max().getAsInt();
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            int hours = 0;
            
            for (int p : piles) {
                hours += (p + mid - 1) / mid; // ceil(p / mid)
            }
            
            if (hours > h) left = mid + 1;
            else right = mid;
        }
        return left;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        left, right = 1, max(piles)
        
        while left < right:
            mid = (left + right) // 2
            hours = sum((p + mid - 1) // mid for p in piles)  # ceil(p / mid)
            
            if hours > h:
                left = mid + 1
            else:
                right = mid
        
        return left
```
{% endtab %}
{% endtabs %}

***

## **ğŸ¯ Äiá»ƒm chÃ­nh**

âœ” **DÃ¹ng Binary Search Ä‘á»ƒ giáº£m thá»i gian tá»« `O(n * max(piles))` xuá»‘ng `O(n log max(piles))`.**\
âœ” **TÃ­nh sá»‘ giá» Äƒn báº±ng `ceil(p / k)`, cÃ³ thá»ƒ tÃ­nh báº±ng `(p + k - 1) / k`.**\
âœ” **Binary Search tÃ¬m kiáº¿m `k` nhá» nháº¥t mÃ  váº«n Ä‘Ã¡p á»©ng Ä‘iá»u kiá»‡n `h`.**

***

## **â³ Äá»™ phá»©c táº¡p thuáº­t toÃ¡n**

| PhÆ°Æ¡ng phÃ¡p          | Äá»™ phá»©c táº¡p           |
| -------------------- | --------------------- |
| **Duyá»‡t tuyáº¿n tÃ­nh** | `O(n * max(piles))`   |
| **Binary Search**    | `O(n log max(piles))` |

ğŸ“Œ **Binary Search lÃ  tá»‘i Æ°u nháº¥t.** ğŸš€

***

## **ğŸ“Œ Tá»•ng káº¿t**

* âœ… **DÃ¹ng Binary Search (`O(n log max(piles))`) Ä‘á»ƒ tÃ¬m tá»‘c Ä‘á»™ tá»‘i thiá»ƒu `k`.**
* âœ… **TÃ­nh sá»‘ giá» Äƒn báº±ng `ceil(p / k)`, tá»‘i Æ°u qua `(p + k - 1) / k`.**
* âœ… **Binary Search giÃºp giáº£m thá»i gian Ä‘Ã¡ng ká»ƒ so vá»›i duyá»‡t tuyáº¿n tÃ­nh.**
