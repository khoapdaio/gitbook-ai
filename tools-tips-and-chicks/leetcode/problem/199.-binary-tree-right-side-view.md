# 199. Binary Tree Right Side View

## Problem

[https://leetcode.com/problems/binary-tree-right-side-view/](https://leetcode.com/problems/binary-tree-right-side-view/)

## **üìå M√¥ t·∫£ b√†i to√°n**

Cho m·ªôt **c√¢y nh·ªã ph√¢n**, h√£y tr·∫£ v·ªÅ **m·∫£ng ch·ª©a c√°c gi√° tr·ªã c·ªßa c√°c node nh√¨n th·∫•y t·ª´ b√™n ph·∫£i**.

üìå **R√†ng bu·ªôc:**

* `1 <= Number of nodes <= 100`
* `-100 <= Node.val <= 100`

***

## **üí° V√≠ d·ª•**

#### ‚úÖ **V√≠ d·ª• 1**

```
Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]
```

üìå **C√¢y nh·ªã ph√¢n:**

```
      1  <- nh√¨n th·∫•y
     / \
    2   3  <- nh√¨n th·∫•y
     \    \
      5    4  <- nh√¨n th·∫•y
```

üîπ **Node nh√¨n th·∫•y t·ª´ ph·∫£i:** `[1, 3, 4]`

***

#### ‚úÖ **V√≠ d·ª• 2**

```
Input: root = [1,null,3]
Output: [1,3]
```

üìå **C√¢y nh·ªã ph√¢n:**

```
    1  <- nh√¨n th·∫•y
     \
      3  <- nh√¨n th·∫•y
```

üîπ **Node nh√¨n th·∫•y t·ª´ ph·∫£i:** `[1, 3]`

***

## **üöÄ Gi·∫£i ph√°p 1: Duy·ªát BFS theo t·∫ßng**

#### üìå **√ù t∆∞·ªüng ch√≠nh:**

* Duy·ªát c√¢y theo **t·ª´ng t·∫ßng (level order traversal)**.
* L·∫•y **node cu·ªëi c√πng** c·ªßa m·ªói t·∫ßng (v√¨ ƒë√≥ l√† node nh√¨n th·∫•y t·ª´ ph·∫£i).
* D√πng **Queue** ƒë·ªÉ duy·ªát **BFS**.

***

## üìú Code

#### ‚úÖ **Java - BFS v·ªõi Queue**

```java
import java.util.*;

class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) return result;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            int lastValue = 0;

            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                lastValue = node.val;

                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }

            result.add(lastValue);
        }
        return result;
    }
}
```

‚úÖ **√ù t∆∞·ªüng:**

* Duy·ªát c√¢y theo **BFS**.
* Duy·ªát t·ª´ng t·∫ßng, l·∫•y node **cu·ªëi c√πng** trong t·∫ßng ƒë√≥ (`lastValue`).

‚è≥ **ƒê·ªô ph·ª©c t·∫°p:**

* **Th·ªùi gian:** `O(n)`, v√¨ duy·ªát t·∫•t c·∫£ `n` node.
* **Kh√¥ng gian:** `O(n)`, v√¨ l∆∞u tr·ªØ `queue`.

***

## **üöÄ Gi·∫£i ph√°p 2: DFS (Preorder Traversal - Right First)**

#### üìå **√ù t∆∞·ªüng ch√≠nh:**

* Duy·ªát c√¢y theo **DFS** v·ªõi **th·ª© t·ª± Right -> Left**.
* Duy·ªát t·ª´ng t·∫ßng, l∆∞u node ƒë·∫ßu ti√™n c·ªßa m·ªói t·∫ßng v√†o `result`.

***

## üìú Code

#### ‚úÖ **Java - DFS ƒë·ªá quy**

```java
import java.util.*;

class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        dfs(root, 0, result);
        return result;
    }

    private void dfs(TreeNode node, int level, List<Integer> result) {
        if (node == null) return;

        if (level == result.size()) {
            result.add(node.val);
        }

        dfs(node.right, level + 1, result);
        dfs(node.left, level + 1, result);
    }
}
```

‚úÖ **√ù t∆∞·ªüng:**

* Duy·ªát c√¢y theo **DFS** v·ªõi **∆∞u ti√™n nh√°nh ph·∫£i tr∆∞·ªõc**.
* Khi duy·ªát **t·∫ßng m·ªõi** (`level == result.size()`), l∆∞u node ƒë·∫ßu ti√™n c·ªßa t·∫ßng v√†o `result`.

‚è≥ **ƒê·ªô ph·ª©c t·∫°p:**

* **Th·ªùi gian:** `O(n)`, v√¨ duy·ªát t·∫•t c·∫£ `n` node.
* **Kh√¥ng gian:** `O(h)`, v·ªõi `h` l√† chi·ªÅu cao c·ªßa c√¢y (t·ªá nh·∫•t `O(n)`).

***

## **üìå T·ªïng k·∫øt**

| Ph∆∞∆°ng ph√°p           | Th·ªùi gian | Kh√¥ng gian |
| --------------------- | --------- | ---------- |
| **BFS (Queue)**       | `O(n)`    | `O(n)`     |
| **DFS (Right First)** | `O(n)`    | `O(h)`     |

‚úÖ **DFS th∆∞·ªùng t·ªëi ∆∞u h∆°n v·ªÅ kh√¥ng gian n·∫øu c√¢y c√≥ chi·ªÅu cao nh·ªè**.
