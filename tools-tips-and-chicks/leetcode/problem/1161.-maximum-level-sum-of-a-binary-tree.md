# 1161. Maximum Level Sum of a Binary Tree

## Problem

[https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree)

## **üìå M√¥ t·∫£ b√†i to√°n**

Cho m·ªôt **c√¢y nh·ªã ph√¢n**, h√£y t√¨m **t·∫ßng (level)** c√≥ t·ªïng gi√° tr·ªã c√°c node l·ªõn nh·∫•t.

* N·∫øu c√≥ nhi·ªÅu t·∫ßng c√≥ t·ªïng l·ªõn nh·∫•t, tr·∫£ v·ªÅ **t·∫ßng c√≥ ch·ªâ s·ªë nh·ªè nh·∫•t**.
* T·∫ßng ƒë·∫ßu ti√™n c√≥ ch·ªâ s·ªë l√† `1`.

üìå **R√†ng bu·ªôc:**

* `1 <= Number of nodes <= 10‚Å¥`
* `-10‚Åµ <= Node.val <= 10‚Åµ`

***

## **üí° V√≠ d·ª•**

#### ‚úÖ **V√≠ d·ª• 1**

```
Input: root = [1,7,0,7,-8,null,null]
Output: 2
```

üìå **C√¢y nh·ªã ph√¢n:**

```
      1
     / \
    7   0
   / \
  7  -8
```

üîπ **T·ªïng theo t·∫ßng:**

* Level 1: `1`
* Level 2: `7 + 0 = 7`
* Level 3: `7 + (-8) = -1`

üîπ **Level c√≥ t·ªïng l·ªõn nh·∫•t:** **Level 2** ‚Üí **K·∫øt qu·∫£: `2`**

***

#### ‚úÖ **V√≠ d·ª• 2**

```
Input: root = [989,null,10250,98693,-89388,null,null,null,-32127]
Output: 2
```

***

## **üöÄ Gi·∫£i ph√°p: BFS duy·ªát theo t·∫ßng**

#### üìå **√ù t∆∞·ªüng ch√≠nh:**

* Duy·ªát **BFS (level-order traversal)** ƒë·ªÉ t√≠nh t·ªïng c·ªßa t·ª´ng t·∫ßng.
* L∆∞u t·∫ßng c√≥ t·ªïng l·ªõn nh·∫•t.

***

## üìúCode

{% tabs %}
{% tab title="C++" %}
```cpp
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    int maxLevelSum(TreeNode* root) {
        if (!root) return 0;
        
        queue<TreeNode*> q;
        q.push(root);
        
        int maxSum = INT_MIN, maxLevel = 1, level = 1;
        
        while (!q.empty()) {
            int size = q.size();
            int sum = 0;
            
            for (int i = 0; i < size; i++) {
                TreeNode* node = q.front(); q.pop();
                sum += node->val;
                
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            
            if (sum > maxSum) {
                maxSum = sum;
                maxLevel = level;
            }
            
            level++;
        }
        
        return maxLevel;
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
import java.util.*;

class Solution {
    public int maxLevelSum(TreeNode root) {
        if (root == null) return 0;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        int maxSum = Integer.MIN_VALUE;
        int maxLevel = 1, level = 1;

        while (!queue.isEmpty()) {
            int size = queue.size();
            int sum = 0;

            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                sum += node.val;

                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }

            if (sum > maxSum) {
                maxSum = sum;
                maxLevel = level;
            }

            level++;
        }
        return maxLevel;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxLevelSum(self, root: TreeNode) -> int:
        if not root:
            return 0

        queue = deque([root])
        max_sum = float('-inf')
        max_level = 1
        level = 1

        while queue:
            level_sum = sum(node.val for node in queue)

            if level_sum > max_sum:
                max_sum = level_sum
                max_level = level

            for _ in range(len(queue)):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            level += 1

        return max_level
```
{% endtab %}
{% endtabs %}

***

## **üöÄ Gi·∫£i ph√°p:  D√πng DFS (Depth-First Search)**

Thay v√¨ s·ª≠ d·ª•ng **BFS** ƒë·ªÉ duy·ªát theo t·∫ßng, ta c√≥ th·ªÉ d√πng **DFS** (ƒë·ªá quy ho·∫∑c stack) ƒë·ªÉ t√≠nh t·ªïng c·ªßa t·ª´ng t·∫ßng.

* D√πng **m·ªôt danh s√°ch `levelSum[]`** ƒë·ªÉ l∆∞u t·ªïng c·ªßa m·ªói t·∫ßng.
* Duy·ªát **DFS (Preorder)**, c·∫≠p nh·∫≠t t·ªïng c·ªßa t·∫ßng hi·ªán t·∫°i.
* T√¨m t·∫ßng c√≥ t·ªïng l·ªõn nh·∫•t.

***

## üìúCode

{% tabs %}
{% tab title="C++" %}
```cpp
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    void dfs(TreeNode* node, int level, vector<int>& levelSum) {
        if (!node) return;

        if (level >= levelSum.size()) levelSum.push_back(0);
        levelSum[level] += node->val;

        dfs(node->left, level + 1, levelSum);
        dfs(node->right, level + 1, levelSum);
    }

    int maxLevelSum(TreeNode* root) {
        vector<int> levelSum;
        dfs(root, 0, levelSum);

        int maxSum = INT_MIN, maxLevel = 1;
        for (int i = 0; i < levelSum.size(); i++) {
            if (levelSum[i] > maxSum) {
                maxSum = levelSum[i];
                maxLevel = i + 1; // V√¨ level b·∫Øt ƒë·∫ßu t·ª´ 1
            }
        }
        return maxLevel;
    }
};
```


{% endtab %}

{% tab title="Java" %}
```java
import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int x) { val = x; }
}

class Solution {
    private void dfs(TreeNode node, int level, List<Integer> levelSum) {
        if (node == null) return;

        if (level >= levelSum.size()) levelSum.add(0);
        levelSum.set(level, levelSum.get(level) + node.val);

        dfs(node.left, level + 1, levelSum);
        dfs(node.right, level + 1, levelSum);
    }

    public int maxLevelSum(TreeNode root) {
        List<Integer> levelSum = new ArrayList<>();
        dfs(root, 0, levelSum);

        int maxSum = Integer.MIN_VALUE, maxLevel = 1;
        for (int i = 0; i < levelSum.size(); i++) {
            if (levelSum.get(i) > maxSum) {
                maxSum = levelSum.get(i);
                maxLevel = i + 1;
            }
        }
        return maxLevel;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxLevelSum(self, root: TreeNode) -> int:
        level_sum = []

        def dfs(node, level):
            if not node:
                return
            if level >= len(level_sum):
                level_sum.append(0)
            level_sum[level] += node.val

            dfs(node.left, level + 1)
            dfs(node.right, level + 1)

        dfs(root, 0)

        max_level = max(range(len(level_sum)), key=lambda i: level_sum[i]) + 1
        return max_level
```
{% endtab %}
{% endtabs %}

## ‚è≥ **ƒê·ªô ph·ª©c t·∫°p:**

| Ph∆∞∆°ng ph√°p        | Th·ªùi gian | Kh√¥ng gian |
| ------------------ | --------- | ---------- |
| **BFS (Queue)**    | `O(n)`    | `O(n)`     |
| **DFS (Preorder)** | `O(n)`    | `O(h)`     |

üí° **DFS c√≥ l·ª£i th·∫ø v·ªÅ kh√¥ng gian n·∫øu c√¢y c√¢n b·∫±ng (`O(log n)`) so v·ªõi `O(n)` c·ªßa BFS**.
