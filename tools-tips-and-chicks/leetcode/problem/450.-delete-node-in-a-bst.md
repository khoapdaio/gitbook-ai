# 450. Delete Node in a BST

## Problem

[https://leetcode.com/problems/delete-node-in-a-bst](https://leetcode.com/problems/delete-node-in-a-bst)

## **üìù M√¥ t·∫£**

Cho m·ªôt **Binary Search Tree (BST)** v√† m·ªôt gi√° tr·ªã `key`, h√£y **x√≥a node c√≥ gi√° tr·ªã `key`** ra kh·ªèi c√¢y v√† tr·∫£ v·ªÅ BST sau khi x√≥a.\
BST v·∫´n ph·∫£i **duy tr√¨ ƒë√∫ng t√≠nh ch·∫•t** sau khi x√≥a.

***

## **üí° V√≠ d·ª•:**

#### ‚úÖ **V√≠ d·ª• 1:**

**Input:**

```
         5
        / \
       3   6
      / \   \
     2   4   7
key = 3
```

**Output:**

```
         5
        / \
       4   6
      /     \
     2       7
```

**Gi·∫£i th√≠ch:**

* Node `3` c√≥ **hai con** (`2, 4`).
* Node nh·ªè nh·∫•t b√™n ph·∫£i (`4`) thay th·∫ø node `3`, sau ƒë√≥ x√≥a `4` ·ªü v·ªã tr√≠ c≈©.

***

#### ‚úÖ **V√≠ d·ª• 2:**

**Input:**

```
       5
      / \
     3   6
    / \   \
   2   4   7
key = 0
```

**Output:**

```
       5
      / \
     3   6
    / \   \
   2   4   7
```

**Gi·∫£i th√≠ch:**

* Kh√¥ng t√¨m th·∫•y `0` trong BST, **kh√¥ng c√≥ thay ƒë·ªïi.**

***

#### ‚úÖ **V√≠ d·ª• 3:**

**Input:**

```
         5
        / \
       3   6
      /     \
     2       7
key = 3
```

**Output:**

```
         5
        / \
       2   6
            \
             7
```

**Gi·∫£i th√≠ch:**

* Node `3` c√≥ **m·ªôt con (`2`)**, thay th·∫ø tr·ª±c ti·∫øp b·∫±ng `2`.

***

## **üöÄ Gi·∫£i ph√°p**&#x20;

‚úÖ **ƒê·ªá quy (Recursive DFS)**

&#x20;**T√¨m node c·∫ßn x√≥a**, sau ƒë√≥ x·ª≠ l√Ω theo c√°c tr∆∞·ªùng h·ª£p:

1. **Node kh√¥ng c√≥ con** ü°™ X√≥a tr·ª±c ti·∫øp.
2. **Node c√≥ ƒë√∫ng m·ªôt con** ü°™ Thay th·∫ø node b·∫±ng con c·ªßa n√≥.
3. **Node c√≥ hai con** ü°™ Thay node b·∫±ng **node nh·ªè nh·∫•t b√™n ph·∫£i**, sau ƒë√≥ x√≥a node ƒë√≥ ƒëi.

***

## **üìú**Code

{% tabs %}
{% tab title="C++" %}
```cpp
class Solution {
public:
    TreeNode* findMin(TreeNode* node) {
        while (node->left) node = node->left;
        return node;
    }

    TreeNode* deleteNode(TreeNode* root, int key) {
        if (!root) return nullptr;
        
        if (key < root->val) root->left = deleteNode(root->left, key);
        else if (key > root->val) root->right = deleteNode(root->right, key);
        else {
            if (!root->left) return root->right;
            if (!root->right) return root->left;

            TreeNode* minRight = findMin(root->right);
            root->val = minRight->val;
            root->right = deleteNode(root->right, minRight->val);
        }
        return root;
    }
};
```
{% endtab %}

{% tab title="Java" %}
```java
class Solution {
    public TreeNode findMin(TreeNode node) {
        while (node.left != null) node = node.left;
        return node;
    }

    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null;

        if (key < root.val) root.left = deleteNode(root.left, key);
        else if (key > root.val) root.right = deleteNode(root.right, key);
        else {
            if (root.left == null) return root.right;
            if (root.right == null) return root.left;

            TreeNode minRight = findMin(root.right);
            root.val = minRight.val;
            root.right = deleteNode(root.right, minRight.val);
        }
        return root;
    }
}
```
{% endtab %}

{% tab title="Python" %}
```python
class Solution:
    def findMin(self, node):
        while node.left:
            node = node.left
        return node

    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if not root:
            return None
        
        if key < root.val:
            root.left = self.deleteNode(root.left, key)
        elif key > root.val:
            root.right = self.deleteNode(root.right, key)
        else:
            if not root.left:
                return root.right
            if not root.right:
                return root.left
            
            minRight = self.findMin(root.right)
            root.val = minRight.val
            root.right = self.deleteNode(root.right, minRight.val)

        return root
```
{% endtab %}
{% endtabs %}

***

## **üéØ ƒêi·ªÉm ch√≠nh**

‚úî **BST Property** gi√∫p ta t√¨m node c·∫ßn x√≥a trong `O(h)`.\
‚úî **D√πng ƒë·ªá quy** ƒë·ªÉ x·ª≠ l√Ω t·ª´ng tr∆∞·ªùng h·ª£p (kh√¥ng con, m·ªôt con, hai con).\
‚úî **T√¨m node nh·ªè nh·∫•t b√™n ph·∫£i** ƒë·ªÉ thay th·∫ø node c·∫ßn x√≥a n·∫øu n√≥ c√≥ **hai con**.

***

## **‚è≥ ƒê·ªô ph·ª©c t·∫°p thu·∫≠t to√°n**

| Ph∆∞∆°ng ph√°p                | Th·ªùi gian | Kh√¥ng gian            |
| -------------------------- | --------- | --------------------- |
| **ƒê·ªá quy (Recursive DFS)** | `O(h)`    | `O(h)` (stack ƒë·ªá quy) |

‚è≥ **Trung b√¨nh `O(log n)`, t·ªá nh·∫•t `O(n)` n·∫øu c√¢y m·∫•t c√¢n b·∫±ng.**

***

## **üìå T·ªïng k·∫øt**

* **B√†i to√°n** y√™u c·∫ßu x√≥a m·ªôt node trong **BST** m√† v·∫´n duy tr√¨ t√≠nh ch·∫•t BST.
* **D√πng ƒë·ªá quy** ƒë·ªÉ t√¨m node c·∫ßn x√≥a v√† x·ª≠ l√Ω theo **ba tr∆∞·ªùng h·ª£p** (kh√¥ng con, m·ªôt con, hai con).
* **T√¨m node nh·ªè nh·∫•t b√™n ph·∫£i** ƒë·ªÉ thay th·∫ø node c·∫ßn x√≥a n·∫øu n√≥ c√≥ **hai con**.
* **Th·ªùi gian `O(h)`, trung b√¨nh `O(log n)`, t·ªá nh·∫•t `O(n)`.**
* ‚úÖ **Gi·∫£i ph√°p hi·ªáu qu·∫£ cho BST.**
